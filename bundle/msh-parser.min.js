!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).MSHParserLib={})}(this,(function(e){"use strict";function t(e){return new r(e)}function s(e,s){if("string"==typeof e)if("undefined"!=typeof window){const r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{const e=t(r.response);s(e)},r.send()}else import("fs").then((r=>{const o=r.readFileSync(e);s(t(o))}));else{const r=new FileReader;r.onload=()=>{const e=t(r.result);s(e)},r.readAsArrayBuffer(e)}}class r{constructor(e){this._offset=0;const t=e.buffer?new Uint8Array(e).buffer:e,s=new DataView(t),o=new Uint8Array(s.buffer);"$MeshFormat"!==this._parseNextLineAsUTF8(o)&&r._throwInvalidFormatError();const[n,i,h]=this._parseNextLineAsUTF8(o).split(" ").map((e=>parseFloat(e)));if((isNaN(n)||isNaN(i)||isNaN(h))&&r._throwInvalidFormatError(),8!==h&&4!==h)throw new Error(`msh-parser: This library currently parses .msh files with data size === 8 or 4.  Current file has data size = ${h}. Please submit an issue to the GitHub repo if you encounter this error and attach a sample file.`);const a=8===h,l=1===i;let f=!1;l&&(1===s.getInt32(this._offset,!0)&&(f=!0),this._offset+=4),"$EndMeshFormat"!==this._parseNextLineAsUTF8(o)&&r._throwInvalidFormatError(),"$Nodes"!==this._parseNextLineAsUTF8(o)&&r._throwInvalidFormatError();const d=parseInt(this._parseNextLineAsUTF8(o)),m=a?new Float64Array(3*d):new Float32Array(3*d);if(!l)throw new Error("msh-parser: This library does not currently parse non-binary .msh files.  Please submit an issue to the GitHub repo if you encounter this error and attach a sample file.");for(let e=0;e<d;e++){const e=s.getInt32(this._offset,f)-1;a?(m[3*e]=s.getFloat64(this._offset+4,f),m[3*e+1]=s.getFloat64(this._offset+4+h,f),m[3*e+2]=s.getFloat64(this._offset+4+2*h,f)):(m[3*e]=s.getFloat32(this._offset+4,f),m[3*e+1]=s.getFloat32(this._offset+4+h,f),m[3*e+2]=s.getFloat32(this._offset+4+2*h,f)),this._offset+=4+3*h}for(let e=0;e<m.length;e++)if(!r._isFiniteNumber(m[e]))throw new Error("msh-parser: NaN or Inf detected in input file.");"$EndNodes"!==this._parseNextLineAsUTF8(o)&&r._throwInvalidFormatError(),this._nodes=m,"$Elements"!==this._parseNextLineAsUTF8(o)&&r._throwInvalidFormatError();const c=parseInt(this._parseNextLineAsUTF8(o)),u=[];for(let e=0;e<c;e++)u.push([]);this.elements=u;let _=!0,p=0,w=!1;if(!l)throw new Error("msh-parser: This library does not currently parse non-binary .msh files.  Please submit an issue to the GitHub repo if you encounter this error and attach a sample file.");for(;p<c;){const e=s.getInt32(this._offset,f),t=s.getInt32(this._offset+4,f),o=s.getInt32(this._offset+8,f);4!==e&&(_=!1);const n=r._numNodesPerElementType(e);this._offset+=12;for(let e=0;e<t;e++){const e=s.getInt32(this._offset,f)-1;if(e<0||e>=c)throw new Error(`msh-parser: Invalid element index ${e} for numElements === ${c}.`);this._offset+=4;for(let e=0;e<o;e++)s.getInt32(this._offset,f),w||(w=!0,console.warn("msh-parser: This library does not currently parse element tags.")),this._offset+=4;const t=u[e];for(let e=0;e<n;e++){const e=s.getInt32(this._offset,f)-1;if(!r._isFiniteNumber(e))throw new Error("msh-parser: NaN or Inf detected in input file.");if(e<0||e>=d)throw new Error(`msh-parser: Invalid node index ${e} for numNodes === ${d}.`);t.push(e),this._offset+=4}}p+=t}if("$EndElements"!==this._parseNextLineAsUTF8(o)&&r._throwInvalidFormatError(),this.isTetMesh=_,_){const e={};for(let t=0;t<c;t++){const s=u[t];for(let t=0;t<s.length;t++){const o=r._makeTriHash(s[t],s[(t+1)%4],s[(t+2)%4]);if(e[o]){if(e[o].push(s[(t+3)%s.length]),e[o].length>2)throw new Error(`msh-parser: Hit face ${o} more than twice.`)}else e[o]=[s[(t+3)%4]]}}const t=Object.keys(e),s=[],o=new Uint8Array(d);for(let n=0,i=t.length;n<i;n++){const i=t[n];if(1!==e[i].length)continue;const h=t[n].split(","),a=parseInt(h[0]),l=parseInt(h[1]),f=parseInt(h[2]),d=e[i][0],c=r._dotProduct(r._crossProduct(r._vecFromTo(a,l,m),r._vecFromTo(a,f,m)),r._vecFromTo(a,d,m));s.push(c<0?[a,l,f]:[a,f,l]),o[a]=1,o[l]=1,o[f]=1}let n=0;const i=new Int32Array(d);for(let e=0;e<d;e++)o[e]&&(i[e]=n,n++);this._numExteriorNodes=n;for(let e=0;e<d;e++)o[e]||(i[e]=n,n++);const h=m.slice();for(let e=0;e<d;e++)for(let t=0;t<3;t++)h[3*i[e]+t]=m[3*e+t];this._nodes=h;for(let e=0;e<c;e++){const t=u[e];for(let e=0;e<t.length;e++)t[e]=i[t[e]]}for(let e=0;e<s.length;e++){const t=s[e];for(let e=0;e<t.length;e++)t[e]=i[t[e]]}this._exteriorFaces=s}}get nodes(){return this._nodes}set nodes(e){throw new Error("msh-parser: No nodes setter.")}_parseNextLineAsUTF8(e){const t=e.indexOf(10,this._offset),s=r.decoder.decode(e.subarray(this._offset,t));return this._offset=t+1,s}static _throwInvalidFormatError(){throw new Error("msh-parser: Invalid .msh file format.")}static _isFiniteNumber(e){return!isNaN(e)&&e!==1/0&&e!==-1/0}static _numNodesPerElementType(e){switch(e){case 2:return 3;case 3:case 4:return 4;case 5:return 8;default:throw new Error(`msh-parser: Element type ${e} is not supported yet.`)}}static _dotProduct(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}static _crossProduct(e,t){return[e[1]*t[2]-e[2]*t[1],e[2]*t[0]-e[0]*t[2],e[0]*t[1]-e[1]*t[0]]}static _vecFromTo(e,t,s){return[s[3*t]-s[3*e],s[3*t+1]-s[3*e+1],s[3*t+2]-s[3*e+2]]}static _makeTriHash(e,t,s){const r=Math.min(e,t,s),o=Math.max(e,t,s);return`${r},${e+t+s-r-o},${o}`}get edges(){if(!this._edges){const{elements:e,isTetMesh:t}=this;if(!t)throw new Error("msh-parser: MSHMesh.edges is not defined for non-tet meshes.");const s={};for(let t=0,r=e.length;t<r;t++){const r=e[t],o=r.length;for(let e=0;e<o;e++)for(let t=e+1;t<o;t++){if(e===t)continue;const o=r[e],n=r[t];s[`${Math.min(o,n)},${Math.max(o,n)}`]=!0}}const r=Object.keys(s),o=new Uint32Array(2*r.length);for(let e=0,t=r.length;e<t;e++){const t=r[e].split(",");o[2*e]=parseInt(t[0]),o[2*e+1]=parseInt(t[1])}this._edges=o}return this._edges}set edges(e){throw new Error("msh-parser: No edges setter.")}get exteriorEdges(){if(!this._exteriorEdges){const{isTetMesh:e,_exteriorFaces:t}=this;if(!e)throw new Error("msh-parser: MSHMesh.exteriorEdges is not defined for non-tet meshes.");const s={};for(let e=0,r=t.length;e<r;e++){const r=t[e],o=r.length;for(let e=0;e<o;e++)for(let t=e+1;t<o;t++){if(e===t)continue;const o=r[e],n=r[t];s[`${Math.min(o,n)},${Math.max(o,n)}`]=!0}}const r=Object.keys(s),o=new Uint32Array(2*r.length);for(let e=0,t=r.length;e<t;e++){const t=r[e].split(",");o[2*e]=parseInt(t[0]),o[2*e+1]=parseInt(t[1])}this._exteriorEdges=o}return this._exteriorEdges}set exteriorEdges(e){throw new Error("msh-parser: No exteriorEdges setter.")}get exteriorFaces(){if(!this.isTetMesh||!this._exteriorFaces)throw new Error("msh-parser: MSHMesh.exteriorFaces is not defined for non-tet meshes.");return this._exteriorFaces}set exteriorFaces(e){throw new Error("msh-parser: No exteriorFaces setter.")}static _tetrahedronVolume(e,t){const[s,o,n,i]=e,h=r._vecFromTo(i,s,t),a=r._vecFromTo(i,o,t),l=r._vecFromTo(i,n,t);return Math.abs(r._dotProduct(h,r._crossProduct(a,l)))/6}get elementVolumes(){if(!this._elementVolumes){const{elements:e,nodes:t,isTetMesh:s}=this;if(!s)throw new Error("msh-parser: MSHMesh.elementVolumes is not defined for non-tet meshes.");const o=e.length,n=new Float32Array(o);for(let s=0;s<o;s++)n[s]=r._tetrahedronVolume(e[s],t);this._elementVolumes=n}return this._elementVolumes}set elementVolumes(e){throw new Error("msh-parser: No elementVolumes setter.")}get nodalVolumes(){if(!this._nodalVolumes){const{elements:e,nodes:t,isTetMesh:s}=this;if(!s)throw new Error("msh-parser: MSHMesh.nodalVolumes is not defined for non-tet meshes.");const{elementVolumes:r}=this,o=new Float32Array(t.length/3);for(let t=0,s=e.length;t<s;t++){const s=e[t],n=s.length;for(let e=0;e<n;e++){o[s[e]]+=r[t]/n}}this._nodalVolumes=o}return this._nodalVolumes}set nodalVolumes(e){throw new Error("msh-parser: No nodalVolumes setter.")}get numExteriorNodes(){if(!this.isTetMesh||!this._numExteriorNodes)throw new Error("msh-parser: MSHMesh.numExteriorNodes is not defined for non-tet meshes.");return this._numExteriorNodes}set numExteriorNodes(e){throw new Error("msh-parser: No numExteriorNodes setter.")}get boundingBox(){if(!this._boundingBox){const{nodes:e}=this,t=e.length/3,s=[1/0,1/0,1/0],r=[-1/0,-1/0,-1/0];for(let o=0;o<t;o++)s[0]=Math.min(s[0],e[3*o]),s[1]=Math.min(s[1],e[3*o+1]),s[2]=Math.min(s[2],e[3*o+2]),r[0]=Math.max(r[0],e[3*o]),r[1]=Math.max(r[1],e[3*o+1]),r[2]=Math.max(r[2],e[3*o+2]);this._boundingBox={min:s,max:r}}return this._boundingBox}set boundingBox(e){throw new Error("msh-parser: No boundingBox setter.")}scaleNodesToUnitBoundingBox(){const{nodes:e,boundingBox:t}=this,{min:s,max:r}=t,o=[r[0]-s[0],r[1]-s[1],r[2]-s[2]],n=[(r[0]+s[0])/2,(r[1]+s[1])/2,(r[2]+s[2])/2],i=Math.max(o[0],o[1],o[2]),h=e.length/3;for(let t=0;t<h;t++)for(let s=0;s<3;s++)e[3*t+s]=(e[3*t+s]-n[s])/i;return delete this._boundingBox,delete this._nodalVolumes,delete this._elementVolumes,this}}r.decoder=new TextDecoder,e.loadMsh=s,e.loadMshAsync=function(e){return new Promise((t=>{s(e,(e=>{t(e)}))}))},e.parseMsh=t}));
//# sourceMappingURL=msh-parser.min.js.map
