!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).MSHParserLib={})}(this,(function(e){"use strict";function t(e,t){return`${Math.min(e,t)},${Math.max(e,t)}`}function s(e,t,s){const r=Math.min(e,t,s),n=Math.max(e,t,s);return`${r},${e+t+s-r-n},${n}`}function r(e){return new o(e)}function n(e,t){if("string"==typeof e)if("undefined"!=typeof window){const s=new XMLHttpRequest;s.open("GET",e,!0),s.responseType="arraybuffer",s.onload=()=>{const e=r(s.response);t(e)},s.send()}else import("fs").then((s=>{const n=s.readFileSync(e);t(r(n))}));else{const s=new FileReader;s.onload=()=>{const e=r(s.result);t(e)},s.readAsArrayBuffer(e)}}class o{constructor(e){this._offset=0;const t=e.buffer?new Uint8Array(e).buffer:e,s=new DataView(t),r=new Uint8Array(s.buffer);"$MeshFormat"!==this._parseNextLineAsUTF8(r)&&o._throwInvalidFormatError();const[n,i,h]=this._parseNextLineAsUTF8(r).split(" ").map((e=>parseFloat(e)));if((isNaN(n)||isNaN(i)||isNaN(h))&&o._throwInvalidFormatError(),8!==h&&4!==h)throw new Error(`msh-parser: This library currently parses .msh files with data size === 8 or 4.  Current file has data size = ${h}. Please submit an issue to the GitHub repo if you encounter this error and attach a sample file.`);const a=8===h,l=0===i,d=1===i;let c=!1;d&&(1===s.getInt32(this._offset,!0)&&(c=!0),this._offset+=4),"$EndMeshFormat"!==this._parseNextLineAsUTF8(r)&&o._throwInvalidFormatError(),"$Nodes"!==this._parseNextLineAsUTF8(r)&&o._throwInvalidFormatError();const f=parseInt(this._parseNextLineAsUTF8(r)),m=a?new Float64Array(3*f):new Float32Array(3*f);if(d)for(let e=0;e<f;e++){const e=s.getInt32(this._offset,c)-1;a?(m[3*e]=s.getFloat64(this._offset+4,c),m[3*e+1]=s.getFloat64(this._offset+4+h,c),m[3*e+2]=s.getFloat64(this._offset+4+2*h,c)):(m[3*e]=s.getFloat32(this._offset+4,c),m[3*e+1]=s.getFloat32(this._offset+4+h,c),m[3*e+2]=s.getFloat32(this._offset+4+2*h,c)),this._offset+=4+3*h}else{if(!l)throw new Error("msh-parser: This library currently only parses binary and ascii .msh files.  Please submit an issue to the GitHub repo if you encounter this error and attach a sample file.");for(let e=0;e<f;e++){const e=this._parseNextLineAsUTF8(r).trim().split(/\s+/);4!==e.length&&o._throwInvalidFormatError();const t=parseInt(e[0])-1;m[3*t]=parseFloat(e[1]),m[3*t+1]=parseFloat(e[2]),m[3*t+2]=parseFloat(e[3])}}for(let e=0;e<m.length;e++)if(!o._isFiniteNumber(m[e]))throw new Error("msh-parser: NaN or Inf detected in input file.");"$EndNodes"!==this._parseNextLineAsUTF8(r)&&o._throwInvalidFormatError(),this._nodes=m,"$Elements"!==this._parseNextLineAsUTF8(r)&&o._throwInvalidFormatError();const u=parseInt(this._parseNextLineAsUTF8(r)),_=[];for(let e=0;e<u;e++)_.push([]);this._elementIndices=_;let p=!0,w=0,g=!1;if(d)for(;w<u;){const e=s.getInt32(this._offset,c),t=s.getInt32(this._offset+4,c),r=s.getInt32(this._offset+8,c);4!==e&&(p=!1);const n=o._numNodesPerElementType(e);this._offset+=12;for(let e=0;e<t;e++){const e=s.getInt32(this._offset,c)-1;if(e<0||e>=u)throw new Error(`msh-parser: Invalid element index ${e} for numElements === ${u}.`);this._offset+=4;for(let e=0;e<r;e++)g||(g=!0,console.warn("msh-parser: This library does not currently parse element tags.")),this._offset+=4;const t=_[e];for(let e=0;e<n;e++){const e=s.getInt32(this._offset,c)-1;if(!o._isFiniteNumber(e))throw new Error("msh-parser: NaN or Inf detected in input file.");if(e<0||e>=f)throw new Error(`msh-parser: Invalid node index ${e} for numNodes === ${f}.`);t.push(e),this._offset+=4}}w+=t}else{if(!l)throw new Error("msh-parser: This library currently only parses binary and ascii .msh files.  Please submit an issue to the GitHub repo if you encounter this error and attach a sample file.");for(;w<u;){const e=this._parseNextLineAsUTF8(r).trim().split(/\s+/),t=parseInt(e[1]),s=parseInt(e[2]);4!==t&&(p=!1);const n=o._numNodesPerElementType(t),i=1;for(let t=0;t<i;t++){const t=parseInt(e[0])-1;if(t<0||t>=u)throw new Error(`msh-parser: Invalid element index ${t} for numElements === ${u}.`);for(let e=0;e<s;e++)g||(g=!0,console.warn("msh-parser: This library does not currently parse element tags."));const r=_[t];for(let t=0;t<n;t++){const n=parseInt(e[3+s+t])-1;if(!o._isFiniteNumber(n))throw new Error("msh-parser: NaN or Inf detected in input file.");if(n<0||n>=f)throw new Error(`msh-parser: Invalid node index ${n} for numNodes === ${f}.`);r.push(n)}}w+=i}}"$EndElements"!==this._parseNextLineAsUTF8(r)&&o._throwInvalidFormatError(),this._isTetMesh=p,this._calcExteriorFacesIndices()}_calcExteriorFacesIndices(){const{nodes:e,elementIndices:t,isTetMesh:r}=this,n=e.length/3,i=t.length;if(r){const r={};for(let e=0;e<i;e++){const n=t[e];for(let e=0;e<n.length;e++){const t=s(n[e],n[(e+1)%4],n[(e+2)%4]);if(r[t]){if(r[t].push(n[(e+3)%n.length]),r[t].length>2)throw new Error(`msh-parser: Hit face ${t} more than twice.`)}else r[t]=[n[(e+3)%4]]}}const h=Object.keys(r),a=[],l=new Uint8Array(n);for(let t=0,s=h.length;t<s;t++){const s=h[t];if(1!==r[s].length)continue;const n=h[t].split(","),i=parseInt(n[0]),d=parseInt(n[1]),c=parseInt(n[2]),f=r[s][0],m=o._dotProduct(o._crossProduct(o._vecFromTo(i,d,e),o._vecFromTo(i,c,e)),o._vecFromTo(i,f,e));a.push(m<0?[i,d,c]:[i,c,d]),l[i]=1,l[d]=1,l[c]=1}let d=0;const c=new Int32Array(n);for(let e=0;e<n;e++)l[e]&&(c[e]=d,d++);this._numExteriorNodes=d;for(let e=0;e<n;e++)l[e]||(c[e]=d,d++);const f=e.slice();for(let t=0;t<n;t++)for(let s=0;s<3;s++)f[3*c[t]+s]=e[3*t+s];this._nodes=f;for(let e=0;e<i;e++){const s=t[e];for(let e=0;e<s.length;e++)s[e]=c[s[e]]}for(let e=0;e<a.length;e++){const t=a[e];for(let e=0;e<t.length;e++)t[e]=c[t[e]]}this._exteriorFacesIndices=a}}get nodes(){return this._nodes}set nodes(e){throw new Error("msh-parser: No nodes setter.")}get elementIndices(){return this._elementIndices}set elementIndices(e){throw new Error("msh-parser: No elementIndices setter.")}get isTetMesh(){return this._isTetMesh}set isTetMesh(e){throw new Error("msh-parser: No isTetMesh setter.")}_parseNextLineAsUTF8(e){const t=e.indexOf(10,this._offset),s=o.decoder.decode(e.subarray(this._offset,t));return this._offset=t+1,s}static _throwInvalidFormatError(){throw new Error("msh-parser: Invalid .msh file format.")}static _isFiniteNumber(e){return!isNaN(e)&&e!==1/0&&e!==-1/0}static _numNodesPerElementType(e){switch(e){case 2:return 3;case 3:case 4:return 4;case 5:return 8;default:throw new Error(`msh-parser: Element type ${e} is not supported yet.`)}}static _dotProduct(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}static _crossProduct(e,t){return[e[1]*t[2]-e[2]*t[1],e[2]*t[0]-e[0]*t[2],e[0]*t[1]-e[1]*t[0]]}static _vecFromTo(e,t,s){return[s[3*t]-s[3*e],s[3*t+1]-s[3*e+1],s[3*t+2]-s[3*e+2]]}get edgesIndices(){if(!this._edgesIndices){const{elementIndices:e,isTetMesh:s}=this;if(!s)throw new Error("msh-parser: MSHMesh.edgesIndices is not defined for non-tet meshes.");const r={},n=[];for(let s=0,o=e.length;s<o;s++){const o=e[s],i=o.length;for(let e=0;e<i;e++)for(let s=e+1;s<i;s++){const i=o[e],h=o[s],a=t(i,h);void 0===r[a]&&(r[a]=!0,n.push(i,h))}}this._edgesIndices=new Uint32Array(n)}return this._edgesIndices}set edgesIndices(e){throw new Error("msh-parser: No edgesIndices setter.")}get exteriorEdgesIndices(){if(!this._exteriorEdgesIndices){const{isTetMesh:e,_exteriorFacesIndices:s}=this;if(!e)throw new Error("msh-parser: MSHMesh.exteriorEdgesIndices is not defined for non-tet meshes.");const r=function(e){const{facesIndices:s}=e,r=s.length,n={},o=[];for(let e=0;e<r;e++){const r=s[e],i=r.length;for(let e=0;e<i;e++){const s=r[e],h=r[(e+1)%i],a=t(s,h);void 0===n[a]&&(n[a]=!0,o.push(s,h))}}return o}({facesIndices:s});this._exteriorEdgesIndices=new Uint32Array(r)}return this._exteriorEdgesIndices}set exteriorEdgesIndices(e){throw new Error("msh-parser: No exteriorEdgesIndices setter.")}get exteriorFacesIndices(){if(!this.isTetMesh||!this._exteriorFacesIndices)throw new Error("msh-parser: MSHMesh.exteriorFacesIndices is not defined for non-tet meshes.");return this._exteriorFacesIndices}set exteriorFacesIndices(e){throw new Error("msh-parser: No exteriorFacesIndices setter.")}static _tetrahedronVolume(e,t){const[s,r,n,i]=e,h=o._vecFromTo(i,s,t),a=o._vecFromTo(i,r,t),l=o._vecFromTo(i,n,t);return Math.abs(o._dotProduct(h,o._crossProduct(a,l)))/6}get elementVolumes(){if(!this._elementVolumes){const{elementIndices:e,nodes:t,isTetMesh:s}=this;if(!s)throw new Error("msh-parser: MSHMesh.elementVolumes is not defined for non-tet meshes.");const r=e.length,n=new Float32Array(r);for(let s=0;s<r;s++)n[s]=o._tetrahedronVolume(e[s],t);this._elementVolumes=n}return this._elementVolumes}set elementVolumes(e){throw new Error("msh-parser: No elementVolumes setter.")}get nodalVolumes(){if(!this._nodalVolumes){const{elementIndices:e,nodes:t,isTetMesh:s}=this;if(!s)throw new Error("msh-parser: MSHMesh.nodalVolumes is not defined for non-tet meshes.");const{elementVolumes:r}=this,n=new Float32Array(t.length/3);for(let t=0,s=e.length;t<s;t++){const s=e[t],o=s.length;for(let e=0;e<o;e++){n[s[e]]+=r[t]/o}}this._nodalVolumes=n}return this._nodalVolumes}set nodalVolumes(e){throw new Error("msh-parser: No nodalVolumes setter.")}get numExteriorNodes(){if(!this.isTetMesh||!this._numExteriorNodes)throw new Error("msh-parser: MSHMesh.numExteriorNodes is not defined for non-tet meshes.");return this._numExteriorNodes}set numExteriorNodes(e){throw new Error("msh-parser: No numExteriorNodes setter.")}get boundingBox(){return this._boundingBox||(this._boundingBox=function(e){const{vertices:t}=e,s=t.length/3,r=[1/0,1/0,1/0],n=[-1/0,-1/0,-1/0];for(let e=0;e<s;e++)r[0]=Math.min(r[0],t[3*e]),r[1]=Math.min(r[1],t[3*e+1]),r[2]=Math.min(r[2],t[3*e+2]),n[0]=Math.max(n[0],t[3*e]),n[1]=Math.max(n[1],t[3*e+1]),n[2]=Math.max(n[2],t[3*e+2]);return{min:r,max:n}}({vertices:this.nodes})),this._boundingBox}set boundingBox(e){throw new Error("msh-parser: No boundingBox setter.")}removeNonTetElements(){const{elementIndices:e,isTetMesh:t}=this;if(t)return this;const s=[];for(let t=e.length-1;t>=0;t--){const r=e[t];4===r.length&&s.push(r)}return this._elementIndices=s,this._isTetMesh=!0,delete this._edgesIndices,delete this._exteriorEdgesIndices,delete this._elementVolumes,delete this._nodalVolumes,delete this._boundingBox,this._calcExteriorFacesIndices(),this}scaleNodesToUnitBoundingBox(){return function(e,t=e.vertices){const{vertices:s,boundingBox:r}=e,{min:n,max:o}=r,i=[o[0]-n[0],o[1]-n[1],o[2]-n[2]],h=[(o[0]+n[0])/2,(o[1]+n[1])/2,(o[2]+n[2])/2],a=Math.max(i[0],i[1],i[2]),l=s.length/3;for(let e=0;e<l;e++)for(let r=0;r<3;r++)t[3*e+r]=(s[3*e+r]-h[r])/a}({vertices:this.nodes,boundingBox:this.boundingBox}),delete this._boundingBox,delete this._nodalVolumes,delete this._elementVolumes,this}}o.decoder=new TextDecoder,e.loadMSH=n,e.loadMSHAsync=function(e){return new Promise((t=>{n(e,(e=>{t(e)}))}))},e.parseMSH=r}));
//# sourceMappingURL=msh-parser.min.js.map
