!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).MSHParserLib={})}(this,(function(e){"use strict";function t(e,t){return`${Math.min(e,t)},${Math.max(e,t)}`}function r(e,t,r){const s=Math.min(e,t,r),o=Math.max(e,t,r);return`${s},${e+t+r-s-o},${o}`}function s(e){return new n(e)}function o(e,t){if("string"==typeof e)if("undefined"!=typeof window){const r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{const e=s(r.response);t(e)},r.send()}else import("fs").then((r=>{const o=r.readFileSync(e);t(s(o))}));else{const r=new FileReader;r.onload=()=>{const e=s(r.result);t(e)},r.readAsArrayBuffer(e)}}class n{constructor(e){this._offset=0;const t=e.buffer?new Uint8Array(e).buffer:e,s=new DataView(t),o=new Uint8Array(s.buffer);"$MeshFormat"!==this._parseNextLineAsUTF8(o)&&n._throwInvalidFormatError();const[i,h,a]=this._parseNextLineAsUTF8(o).split(" ").map((e=>parseFloat(e)));if((isNaN(i)||isNaN(h)||isNaN(a))&&n._throwInvalidFormatError(),8!==a&&4!==a)throw new Error(`msh-parser: This library currently parses .msh files with data size === 8 or 4.  Current file has data size = ${a}. Please submit an issue to the GitHub repo if you encounter this error and attach a sample file.`);const d=8===a,l=1===h;let f=!1;l&&(1===s.getInt32(this._offset,!0)&&(f=!0),this._offset+=4),"$EndMeshFormat"!==this._parseNextLineAsUTF8(o)&&n._throwInvalidFormatError(),"$Nodes"!==this._parseNextLineAsUTF8(o)&&n._throwInvalidFormatError();const c=parseInt(this._parseNextLineAsUTF8(o)),m=d?new Float64Array(3*c):new Float32Array(3*c);if(!l)throw new Error("msh-parser: This library does not currently parse non-binary .msh files.  Please submit an issue to the GitHub repo if you encounter this error and attach a sample file.");for(let e=0;e<c;e++){const e=s.getInt32(this._offset,f)-1;d?(m[3*e]=s.getFloat64(this._offset+4,f),m[3*e+1]=s.getFloat64(this._offset+4+a,f),m[3*e+2]=s.getFloat64(this._offset+4+2*a,f)):(m[3*e]=s.getFloat32(this._offset+4,f),m[3*e+1]=s.getFloat32(this._offset+4+a,f),m[3*e+2]=s.getFloat32(this._offset+4+2*a,f)),this._offset+=4+3*a}for(let e=0;e<m.length;e++)if(!n._isFiniteNumber(m[e]))throw new Error("msh-parser: NaN or Inf detected in input file.");"$EndNodes"!==this._parseNextLineAsUTF8(o)&&n._throwInvalidFormatError(),this._nodes=m,"$Elements"!==this._parseNextLineAsUTF8(o)&&n._throwInvalidFormatError();const u=parseInt(this._parseNextLineAsUTF8(o)),_=[];for(let e=0;e<u;e++)_.push([]);this.elementIndices=_;let p=!0,w=0,g=!1;if(!l)throw new Error("msh-parser: This library does not currently parse non-binary .msh files.  Please submit an issue to the GitHub repo if you encounter this error and attach a sample file.");for(;w<u;){const e=s.getInt32(this._offset,f),t=s.getInt32(this._offset+4,f),r=s.getInt32(this._offset+8,f);4!==e&&(p=!1);const o=n._numNodesPerElementType(e);this._offset+=12;for(let e=0;e<t;e++){const e=s.getInt32(this._offset,f)-1;if(e<0||e>=u)throw new Error(`msh-parser: Invalid element index ${e} for numElements === ${u}.`);this._offset+=4;for(let e=0;e<r;e++)g||(g=!0,console.warn("msh-parser: This library does not currently parse element tags.")),this._offset+=4;const t=_[e];for(let e=0;e<o;e++){const e=s.getInt32(this._offset,f)-1;if(!n._isFiniteNumber(e))throw new Error("msh-parser: NaN or Inf detected in input file.");if(e<0||e>=c)throw new Error(`msh-parser: Invalid node index ${e} for numNodes === ${c}.`);t.push(e),this._offset+=4}}w+=t}if("$EndElements"!==this._parseNextLineAsUTF8(o)&&n._throwInvalidFormatError(),this.isTetMesh=p,p){const e={};for(let t=0;t<u;t++){const s=_[t];for(let t=0;t<s.length;t++){const o=r(s[t],s[(t+1)%4],s[(t+2)%4]);if(e[o]){if(e[o].push(s[(t+3)%s.length]),e[o].length>2)throw new Error(`msh-parser: Hit face ${o} more than twice.`)}else e[o]=[s[(t+3)%4]]}}const t=Object.keys(e),s=[],o=new Uint8Array(c);for(let r=0,i=t.length;r<i;r++){const i=t[r];if(1!==e[i].length)continue;const h=t[r].split(","),a=parseInt(h[0]),d=parseInt(h[1]),l=parseInt(h[2]),f=e[i][0],c=n._dotProduct(n._crossProduct(n._vecFromTo(a,d,m),n._vecFromTo(a,l,m)),n._vecFromTo(a,f,m));s.push(c<0?[a,d,l]:[a,l,d]),o[a]=1,o[d]=1,o[l]=1}let i=0;const h=new Int32Array(c);for(let e=0;e<c;e++)o[e]&&(h[e]=i,i++);this._numExteriorNodes=i;for(let e=0;e<c;e++)o[e]||(h[e]=i,i++);const a=m.slice();for(let e=0;e<c;e++)for(let t=0;t<3;t++)a[3*h[e]+t]=m[3*e+t];this._nodes=a;for(let e=0;e<u;e++){const t=_[e];for(let e=0;e<t.length;e++)t[e]=h[t[e]]}for(let e=0;e<s.length;e++){const t=s[e];for(let e=0;e<t.length;e++)t[e]=h[t[e]]}this._exteriorFaceIndices=s}}get nodes(){return this._nodes}set nodes(e){throw new Error("msh-parser: No nodes setter.")}_parseNextLineAsUTF8(e){const t=e.indexOf(10,this._offset),r=n.decoder.decode(e.subarray(this._offset,t));return this._offset=t+1,r}static _throwInvalidFormatError(){throw new Error("msh-parser: Invalid .msh file format.")}static _isFiniteNumber(e){return!isNaN(e)&&e!==1/0&&e!==-1/0}static _numNodesPerElementType(e){switch(e){case 2:return 3;case 3:case 4:return 4;case 5:return 8;default:throw new Error(`msh-parser: Element type ${e} is not supported yet.`)}}static _dotProduct(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}static _crossProduct(e,t){return[e[1]*t[2]-e[2]*t[1],e[2]*t[0]-e[0]*t[2],e[0]*t[1]-e[1]*t[0]]}static _vecFromTo(e,t,r){return[r[3*t]-r[3*e],r[3*t+1]-r[3*e+1],r[3*t+2]-r[3*e+2]]}get edgeIndices(){if(!this._edgeIndices){const{elementIndices:e,isTetMesh:r}=this;if(!r)throw new Error("msh-parser: MSHMesh.edgeIndices is not defined for non-tet meshes.");const s={},o=[];for(let r=0,n=e.length;r<n;r++){const n=e[r],i=n.length;for(let e=0;e<i;e++)for(let r=e+1;r<i;r++){const i=n[e],h=n[r],a=t(i,h);void 0===s[a]&&(s[a]=!0,o.push(i,h))}}this._edgeIndices=new Uint32Array(o)}return this._edgeIndices}set edgeIndices(e){throw new Error("msh-parser: No edgeIndices setter.")}get exteriorEdgeIndices(){if(!this._exteriorEdgeIndices){const{isTetMesh:e,_exteriorFaceIndices:r}=this;if(!e)throw new Error("msh-parser: MSHMesh.exteriorEdgeIndices is not defined for non-tet meshes.");const s=function(e){const{faceIndices:r}=e,s=r.length,o={},n=[];for(let e=0;e<s;e++){const s=r[e],i=s.length;for(let e=0;e<i;e++){const r=s[e],h=s[(e+1)%i],a=t(r,h);void 0===o[a]&&(o[a]=!0,n.push(r,h))}}return n}({faceIndices:r});this._exteriorEdgeIndices=new Uint32Array(s)}return this._exteriorEdgeIndices}set exteriorEdgeIndices(e){throw new Error("msh-parser: No exteriorEdgeIndices setter.")}get exteriorFaceIndices(){if(!this.isTetMesh||!this._exteriorFaceIndices)throw new Error("msh-parser: MSHMesh.exteriorFaceIndices is not defined for non-tet meshes.");return this._exteriorFaceIndices}set exteriorFaceIndices(e){throw new Error("msh-parser: No exteriorFaceIndices setter.")}static _tetrahedronVolume(e,t){const[r,s,o,i]=e,h=n._vecFromTo(i,r,t),a=n._vecFromTo(i,s,t),d=n._vecFromTo(i,o,t);return Math.abs(n._dotProduct(h,n._crossProduct(a,d)))/6}get elementVolumes(){if(!this._elementVolumes){const{elementIndices:e,nodes:t,isTetMesh:r}=this;if(!r)throw new Error("msh-parser: MSHMesh.elementVolumes is not defined for non-tet meshes.");const s=e.length,o=new Float32Array(s);for(let r=0;r<s;r++)o[r]=n._tetrahedronVolume(e[r],t);this._elementVolumes=o}return this._elementVolumes}set elementVolumes(e){throw new Error("msh-parser: No elementVolumes setter.")}get nodalVolumes(){if(!this._nodalVolumes){const{elementIndices:e,nodes:t,isTetMesh:r}=this;if(!r)throw new Error("msh-parser: MSHMesh.nodalVolumes is not defined for non-tet meshes.");const{elementVolumes:s}=this,o=new Float32Array(t.length/3);for(let t=0,r=e.length;t<r;t++){const r=e[t],n=r.length;for(let e=0;e<n;e++){o[r[e]]+=s[t]/n}}this._nodalVolumes=o}return this._nodalVolumes}set nodalVolumes(e){throw new Error("msh-parser: No nodalVolumes setter.")}get numExteriorNodes(){if(!this.isTetMesh||!this._numExteriorNodes)throw new Error("msh-parser: MSHMesh.numExteriorNodes is not defined for non-tet meshes.");return this._numExteriorNodes}set numExteriorNodes(e){throw new Error("msh-parser: No numExteriorNodes setter.")}get boundingBox(){return this._boundingBox||(this._boundingBox=function(e){const{vertices:t}=e,r=t.length/3,s=[1/0,1/0,1/0],o=[-1/0,-1/0,-1/0];for(let e=0;e<r;e++)s[0]=Math.min(s[0],t[3*e]),s[1]=Math.min(s[1],t[3*e+1]),s[2]=Math.min(s[2],t[3*e+2]),o[0]=Math.max(o[0],t[3*e]),o[1]=Math.max(o[1],t[3*e+1]),o[2]=Math.max(o[2],t[3*e+2]);return{min:s,max:o}}({vertices:this.nodes})),this._boundingBox}set boundingBox(e){throw new Error("msh-parser: No boundingBox setter.")}scaleNodesToUnitBoundingBox(){return function(e,t=e.vertices){const{vertices:r,boundingBox:s}=e,{min:o,max:n}=s,i=[n[0]-o[0],n[1]-o[1],n[2]-o[2]],h=[(n[0]+o[0])/2,(n[1]+o[1])/2,(n[2]+o[2])/2],a=Math.max(i[0],i[1],i[2]),d=r.length/3;for(let e=0;e<d;e++)for(let s=0;s<3;s++)t[3*e+s]=(r[3*e+s]-h[s])/a}({vertices:this.nodes,boundingBox:this.boundingBox}),delete this._boundingBox,delete this._nodalVolumes,delete this._elementVolumes,this}}n.decoder=new TextDecoder,e.loadMSH=o,e.loadMSHAsync=function(e){return new Promise((t=>{o(e,(e=>{t(e)}))}))},e.parseMSH=s}));
//# sourceMappingURL=msh-parser.min.js.map
