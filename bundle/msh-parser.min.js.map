{"version":3,"file":"msh-parser.min.js","sources":["../src/msh-parser.ts"],"sourcesContent":["/**\n * Synchronously parse an already loaded .msh file buffer.\n */\nexport function parseMsh(data: Buffer | ArrayBuffer): MSHMesh {\n\treturn new _MSHMesh(data);\n}\n/**\n * Load and parse .msh asynchronously from the specified url or File object (returns Promise).\n */\nexport function loadMshAsync(urlOrFile: string | File) {\n\treturn new Promise<MSHMesh>((resolve) => {\n\t\tloadMsh(urlOrFile, (mesh) => {\n\t\t\tresolve(mesh);\n\t\t});\n\t});\n}\n\n/**\n * Load and parse .msh from the specified url or File object.\n */\nexport function loadMsh(urlOrFile: string | File, callback: (mesh: MSHMesh) => void) {\n\tif (typeof urlOrFile === 'string') {\n\t\t// Made this compatible with Node and the browser, maybe there is a better way?\n\t\tif (typeof window !== 'undefined') {\n\t\t\t// Load the file with XMLHttpRequest.\n\t\t\tconst request = new XMLHttpRequest();\n\t\t\trequest.open('GET', urlOrFile, true);\n\t\t\trequest.responseType = 'arraybuffer';\n\t\t\trequest.onload = () => {\n\t\t\t\tconst mesh = parseMsh(request.response as ArrayBuffer);\n\t\t\t\t// Call the callback function with the parsed mesh data.\n\t\t\t\tcallback(mesh);\n\t\t\t};\n\t\t\trequest.send();\n\t\t} else {\n\t\t\t// Call the callback function with the parsed mesh data.\n\t\t\timport('fs').then((fs) => {\n\t\t\t\tconst buffer = fs.readFileSync(urlOrFile);\n\t\t\t\tcallback(parseMsh(buffer));\n\t\t\t});\n\t\t}\n\t} else {\n\t\t// We only ever hit this in the browser.\n\t\t// Load the file with FileReader.\n\t\tconst reader = new FileReader();\n\t\treader.onload = () => {\n\t\t\tconst mesh = parseMsh(reader.result as ArrayBuffer);\n\t\t\t// Call the callback function with the parsed mesh data.\n\t\t\tcallback(mesh);\n\t\t}\n\t\treader.readAsArrayBuffer(urlOrFile);\n\t}\n}\n\n// Export just the type, keep the class private.\nexport type MSHMesh = {\n\treadonly nodes: Float64Array | Float32Array;\n\treadonly elements: number[][];\n\treadonly edges: Uint32Array;\n\treadonly exteriorEdges: Uint32Array;\n\treadonly exteriorFaces: number[][];\n\treadonly elementVolumes: Float32Array;\n\treadonly nodalVolumes: Float32Array;\n\treadonly isTetMesh: boolean;\n\treadonly numExteriorNodes: number;\n\treadonly boundingBox: { min: number[], max: number[] };\n\tscaleNodesToUnitBoundingBox: () => MSHMesh;\n}\n\n// Based on: https://github.com/PyMesh/PyMesh/blob/main/src/IO/MshLoader.cpp\n// Define the MSHMesh class.\nclass _MSHMesh {\n\t// TextDecoder instance to decode the header as UTF-8.\n\tstatic decoder = new TextDecoder();\n\t// Header offset.\n\tprivate _offset = 0;\n\n\tprivate _nodes: Float64Array | Float32Array;\n\treadonly elements: number[][];\n\tprivate _edges?: Uint32Array;\n\tprivate _exteriorEdges?: Uint32Array;\n\tprivate _elementVolumes?: Float32Array;\n\tprivate _nodalVolumes?: Float32Array;\n\tprivate _boundingBox?: { min: number[], max: number[] };\n\treadonly isTetMesh: boolean;\n\tprivate readonly _exteriorFaces?: number[][];\n\tprivate readonly _numExteriorNodes?: number;\n\n\tconstructor(data: ArrayBuffer | Buffer) {\n\t\tconst arrayBuffer = (data as Buffer).buffer ? new Uint8Array(data as Buffer).buffer : data;\n\t\tconst dataView = new DataView(arrayBuffer);\n\t\t// Create a Uint8Array that references the same underlying memory as the DataView.\n\t\tconst uint8Array = new Uint8Array(dataView.buffer);\n\n\t\t// Parse header.\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$MeshFormat') _MSHMesh._throwInvalidFormatError();\n\t\tconst [ version, type, dataSize ] = this._parseNextLineAsUTF8(uint8Array).split(' ').map(el => parseFloat(el));\n\t\tif (isNaN(version) || isNaN(type) || isNaN(dataSize)) _MSHMesh._throwInvalidFormatError();\n\t\tif (dataSize !== 8 && dataSize !== 4) throw new Error(`msh-parser: This library currently parses .msh files with data size === 8 or 4.  Current file has data size = ${dataSize}. Please submit an issue to the GitHub repo if you encounter this error and attach a sample file.`);\n\t\tconst doublePrecision = dataSize === 8;\n\t\tconst isBinary = type === 1;\n\t\tlet isLE = false;\n\t\tif (isBinary) {\n\t\t\t// Read in extra info from binary header.\n\t\t\t// TODO: how do we know to read as LE here?\n\t\t\tif (dataView.getInt32(this._offset, true) === 1) {\n\t\t\t\t// Read as LE.\n\t\t\t\tisLE = true;\n\t\t\t}\n\t\t\tthis._offset += 4;\n\t\t}\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$EndMeshFormat') _MSHMesh._throwInvalidFormatError();\n\n\t\t// Read the number of nodes.\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$Nodes') _MSHMesh._throwInvalidFormatError();\n\t\tconst numNodes = parseInt(this._parseNextLineAsUTF8(uint8Array));\n\t\t// Loop through the nodes.\n\t\tconst nodesArray = doublePrecision ? new Float64Array(3 * numNodes) : new Float32Array(3 * numNodes);\n\t\tif (isBinary) {\n\t\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\t\t// Read the current node.\n\t\t\t\tconst index = dataView.getInt32(this._offset, isLE) - 1; // The .msh node index is 1-indexed.\n\t\t\t\tif (doublePrecision) {\n\t\t\t\t\tnodesArray[3 * index] = dataView.getFloat64(this._offset + 4, isLE);\n\t\t\t\t\tnodesArray[3 * index + 1] = dataView.getFloat64(this._offset + 4 + dataSize, isLE);\n\t\t\t\t\tnodesArray[3 * index + 2] = dataView.getFloat64(this._offset + 4 + 2 * dataSize, isLE);\n\t\t\t\t} else {\n\t\t\t\t\tnodesArray[3 * index] = dataView.getFloat32(this._offset + 4, isLE);\n\t\t\t\t\tnodesArray[3 * index + 1] = dataView.getFloat32(this._offset + 4 + dataSize, isLE);\n\t\t\t\t\tnodesArray[3 * index + 2] = dataView.getFloat32(this._offset + 4 + 2 * dataSize, isLE);\n\t\t\t\t}\n\t\t\t\t// Update the current file's byte offset.\n\t\t\t\tthis._offset += 4 + 3 * dataSize;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('msh-parser: This library does not currently parse non-binary .msh files.  Please submit an issue to the GitHub repo if you encounter this error and attach a sample file.');\n\t\t}\n\t\t// Check that all nodes are finite.\n\t\tfor (let i = 0; i < nodesArray.length; i++) {\n\t\t\tif (!_MSHMesh._isFiniteNumber(nodesArray[i])) throw new Error('msh-parser: NaN or Inf detected in input file.');\n\t\t}\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$EndNodes') _MSHMesh._throwInvalidFormatError();\n\t\tthis._nodes = nodesArray;\n\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$Elements') _MSHMesh._throwInvalidFormatError();\n\n\t\t// Read the number of elements.\n\t\tconst numElements = parseInt(this._parseNextLineAsUTF8(uint8Array));\n\t\tconst elementsArray: number[][] = [];\n\t\tfor (let i = 0; i < numElements; i++) {\n\t\t\telementsArray.push([]);\n\t\t}\n\t\tthis.elements = elementsArray;\n\n\t\t// Check if all elements are tetrahedra.\n\t\tlet isTetMesh = true;\n\t\t// Loop through the elements.\n\t\tlet elementIndex = 0;\n\t\tlet tagWarning = false;\n\t\tif (isBinary) {\n\t\t\twhile (elementIndex < numElements) {\n\t\t\t\t// Parse element header.\n\t\t\t\tconst elementType = dataView.getInt32(this._offset, isLE);\n\t\t\t\tconst elementNumElements = dataView.getInt32(this._offset + 4, isLE);\n\t\t\t\tconst elementNumTags = dataView.getInt32(this._offset + 8, isLE);\n\t\t\t\tif (elementType !== 4) isTetMesh = false;\n\t\t\t\tconst numElementNodes = _MSHMesh._numNodesPerElementType(elementType);\n\t\t\t\t// Update the current file's byte offset.\n\t\t\t\tthis._offset += 12;\n\t\t\t\tfor (let i = 0; i < elementNumElements; i++) {\n\t\t\t\t\tconst index = dataView.getInt32(this._offset, isLE) - 1; // The .msh index is 1-indexed.\n\t\t\t\t\tif (index < 0 || index >= numElements) throw new Error(`msh-parser: Invalid element index ${index} for numElements === ${numElements}.`);\n\t\t\t\t\tthis._offset += 4;\n\t\t\t\t\tfor (let j = 0; j < elementNumTags; j++) {\n\t\t\t\t\t\tconst tag = dataView.getInt32(this._offset, isLE);\n\t\t\t\t\t\tif (!tagWarning) {\n\t\t\t\t\t\t\ttagWarning = true;\n\t\t\t\t\t\t\tconsole.warn('msh-parser: This library does not currently parse element tags.');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Update the current file's byte offset.\n\t\t\t\t\t\tthis._offset += 4;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconst nodeIndices = elementsArray[index];\n\t\t\t\t\tfor (let j = 0; j < numElementNodes; j++) {\n\t\t\t\t\t\tconst nodeIndex = dataView.getInt32(this._offset, isLE) - 1; // The .msh index is 1-indexed.\n\t\t\t\t\t\tif (!_MSHMesh._isFiniteNumber(nodeIndex)) throw new Error('msh-parser: NaN or Inf detected in input file.');\n\t\t\t\t\t\tif (nodeIndex < 0 || nodeIndex >= numNodes) throw new Error(`msh-parser: Invalid node index ${nodeIndex} for numNodes === ${numNodes}.`);\n\t\t\t\t\t\tnodeIndices.push(nodeIndex);\n\t\t\t\t\t\t// Update the current file's byte offset.\n\t\t\t\t\t\tthis._offset += 4;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telementIndex += elementNumElements;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('msh-parser: This library does not currently parse non-binary .msh files.  Please submit an issue to the GitHub repo if you encounter this error and attach a sample file.');\n\t\t}\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$EndElements') _MSHMesh._throwInvalidFormatError();\n\n\t\tthis.isTetMesh = isTetMesh;\n\t\t// TODO: make this work for non-tet.\n\t\tif (isTetMesh) {\n\t\t\t// For tet meshes, calculate exterior faces.\n\t\t\t// First find all faces that are covered only once, these are on the boundary.\n\t\t\tconst hash: { [key: string]: number[] } = {};\n\t\t\tfor (let i = 0; i < numElements; i++) {\n\t\t\t\tconst indices = elementsArray[i];\n\t\t\t\tfor (let j = 0; j < indices.length; j++) {\n\t\t\t\t\tconst key = _MSHMesh._makeTriHash(indices[j], indices[(j + 1) % 4], indices[(j + 2) % 4]);\n\t\t\t\t\tif (hash[key]) {\n\t\t\t\t\t\thash[key].push(indices[(j + 3) % indices.length]);\n\t\t\t\t\t\tif (hash[key].length > 2) {\n\t\t\t\t\t\t\tthrow new Error(`msh-parser: Hit face ${key} more than twice.`);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\thash[key] = [indices[(j + 3) % 4]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst keys = Object.keys(hash);\n\t\t\tconst exteriorFacesArray: number[][] = [];\n\t\t\tconst exteriorNodes = new Uint8Array(numNodes);\n\t\t\tfor (let i = 0, numKeys = keys.length; i < numKeys; i++) {\n\t\t\t\tconst key = keys[i];\n\t\t\t\tif (hash[key].length !== 1) continue;\n\t\t\t\tconst indices = keys[i].split(',');\n\t\t\t\tconst a = parseInt(indices[0]);\n\t\t\t\tconst b = parseInt(indices[1]);\n\t\t\t\tconst c = parseInt(indices[2]);\n\t\t\t\t// d is the internal node of this tet.\n\t\t\t\tconst d = hash[key][0];\n\t\t\t\t// Use d to calculate the winding order of the triangle.\n\t\t\t\tconst orientation = _MSHMesh._dotProduct(_MSHMesh._crossProduct(\n\t\t\t\t\t_MSHMesh._vecFromTo(a, b, nodesArray),\n\t\t\t\t\t_MSHMesh._vecFromTo(a, c, nodesArray),\n\t\t\t\t), _MSHMesh._vecFromTo(a, d, nodesArray));\n\t\t\t\texteriorFacesArray.push(orientation < 0 ? [a, b, c] : [a, c, b]);\n\t\t\t\t// Mark all nodes as exterior.\n\t\t\t\texteriorNodes[a] = 1;\n\t\t\t\texteriorNodes[b] = 1;\n\t\t\t\texteriorNodes[c] = 1;\n\t\t\t}\n\t\t\t\n\t\t\t// Also reorder the nodes so that the exterior nodes are first.\n\t\t\tlet currentIndex = 0;\n\t\t\tconst newIndices = new Int32Array(numNodes);\n\t\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\t\tif (exteriorNodes[i]) {\n\t\t\t\t\tnewIndices[i] = currentIndex;\n\t\t\t\t\tcurrentIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._numExteriorNodes = currentIndex;\n\t\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\t\tif (!exteriorNodes[i]) {\n\t\t\t\t\tnewIndices[i] = currentIndex;\n\t\t\t\t\tcurrentIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Now that we have a mapping, update nodesArrays, elementsArray, and exteriorFacesArray.\n\t\t\tconst newNodesArray = nodesArray.slice();\n\t\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\t\tfor (let j = 0; j < 3; j++) {\n\t\t\t\t\tnewNodesArray[3 * newIndices[i] + j] = nodesArray[3 * i + j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._nodes = newNodesArray;\n\t\t\tfor (let i = 0; i < numElements; i++) {\n\t\t\t\tconst indices = elementsArray[i];\n\t\t\t\tfor (let j = 0; j < indices.length; j++) {\n\t\t\t\t\tindices[j] = newIndices[indices[j]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i = 0; i < exteriorFacesArray.length; i++) {\n\t\t\t\tconst indices = exteriorFacesArray[i];\n\t\t\t\tfor (let j = 0; j < indices.length; j++) {\n\t\t\t\t\tindices[j] = newIndices[indices[j]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._exteriorFaces = exteriorFacesArray;\n\t\t}\n\t}\n\n\tget nodes() {\n\t\treturn this._nodes;\n\t}\n\n\tset nodes(nodes: Float32Array | Float64Array) {\n\t\tthrow new Error(`msh-parser: No nodes setter.`);\n\t}\n\n\tprivate _parseNextLineAsUTF8(uint8Array: Uint8Array) {\n\t\t// Find the first newline character in the uint8Array.\n\t\tconst newlineIndex = uint8Array.indexOf(10, this._offset); // 10 is the ASCII code for the newline character.\n\t\t// Decode the uint8Array as a UTF-8 encoded string up until the newline character.\n\t\tconst text = _MSHMesh.decoder.decode(uint8Array.subarray(this._offset, newlineIndex));\n\t\t// Update offset.\n\t\tthis._offset = newlineIndex + 1;\n\t\t// Return the decoded string.\n\t\treturn text;\n\t}\n\n\tprivate static _throwInvalidFormatError() {\n\t\tthrow new Error('msh-parser: Invalid .msh file format.');\n\t}\n\n\tprivate static _isFiniteNumber(number: number) {\n\t\treturn !isNaN(number) && number !== Infinity && number !== -Infinity;\n\t}\n\n\tprivate static _numNodesPerElementType(elementType: number) {\n\t\tswitch (elementType) {\n\t\t\tcase 2:\n\t\t\t\treturn 3; // Triangle\n\t\t\tcase 3:\n\t\t\t\treturn 4; // Quad\n\t\t\tcase 4:\n\t\t\t\treturn 4; // Tetrahedron\n\t\t\tcase 5:\n\t\t\t\treturn 8; // Hexahedron\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`msh-parser: Element type ${elementType} is not supported yet.`);\n\t\t}\n\t}\n\t\n\t// Calculates the dot product of two vectors.\n\tprivate static _dotProduct(vector1: number[], vector2: number[]) {\n\t\treturn vector1[0] * vector2[0] + vector1[1] * vector2[1] + vector1[2] * vector2[2];\n\t}\n\t\n\t// Calculates the cross product of two vectors.\n\tprivate static _crossProduct(vector1: number[], vector2: number[]) {\n\t\treturn [\n\t\t\tvector1[1] * vector2[2] - vector1[2] * vector2[1],\n\t\t\tvector1[2] * vector2[0] - vector1[0] * vector2[2],\n\t\t\tvector1[0] * vector2[1] - vector1[1] * vector2[0]\n\t\t];\n\t}\n\n\tprivate static _vecFromTo(from: number, to: number, nodesArray: Float32Array | Float64Array) {\n\t\treturn [\n\t\t\tnodesArray[3 * to] - nodesArray[3 * from],\n\t\t\tnodesArray[3 * to + 1] - nodesArray[3 * from + 1],\n\t\t\tnodesArray[3 * to + 2] - nodesArray[3 * from + 2],\n\t\t];\n\t}\n\n\tprivate static _makeTriHash(a: number, b: number, c: number) {\n\t\t// Find the minimum and maximum of the input numbers.\n\t\tconst min = Math.min(a, b, c);\n\t\tconst max = Math.max(a, b, c);\n\t  \n\t\t// Find the remaining number.\n\t\tconst remaining = a + b + c - min - max;\n\t  \n\t\t// Join the numbers in ascending order into a string with commas.\n\t\treturn`${min},${remaining},${max}`;\n\t}\n\n\tget edges() {\n\t\tif (!this._edges) {\n\t\t\tconst { elements, isTetMesh } = this;\n\t\t\tif (!isTetMesh) throw new Error(`msh-parser: MSHMesh.edges is not defined for non-tet meshes.`);\n\t\t\t// Calc all edges in mesh, use hash table to cover each edge only once.\n\t\t\tconst hash: { [key: string]: boolean } = {};\n\t\t\tfor (let i = 0, numElements = elements.length; i < numElements; i++) {\n\t\t\t\tconst elementIndices = elements[i];\n\t\t\t\t// For tetrahedra, create an edge between each pair of nodes in element.\n\t\t\t\tconst numNodes = elementIndices.length;\n\t\t\t\tfor (let j = 0; j < numNodes; j++) {\n\t\t\t\t\tfor (let k = j + 1; k < numNodes; k++) {\n\t\t\t\t\t\tif (j === k) continue;\n\t\t\t\t\t\tconst a = elementIndices[j];\n\t\t\t\t\t\tconst b = elementIndices[k];\n\t\t\t\t\t\tconst key = `${Math.min(a, b)},${Math.max(a, b)}`;\n\t\t\t\t\t\thash[key] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst keys = Object.keys(hash);\n\t\t\tconst edgesArray = new Uint32Array(keys.length * 2);\n\t\t\tfor (let i = 0, length = keys.length; i < length; i++) {\n\t\t\t\tconst indices = keys[i].split(',');\n\t\t\t\tedgesArray[2 * i] = parseInt(indices[0]);\n\t\t\t\tedgesArray[2 * i + 1] = parseInt(indices[1]);\n\t\t\t}\n\t\t\tthis._edges = edgesArray;\n\t\t}\n\t\treturn this._edges;\n\t}\n\n\tset edges(edges: Uint32Array) {\n\t\tthrow new Error(`msh-parser: No edges setter.`);\n\t}\n\n\tget exteriorEdges() {\n\t\tif (!this._exteriorEdges) {\n\t\t\tconst { isTetMesh, _exteriorFaces } = this; \n\t\t\tif (!isTetMesh) throw new Error(`msh-parser: MSHMesh.exteriorEdges is not defined for non-tet meshes.`);\n\t\t\t// Calc all exterior edges in mesh, use hash table to cover each edge only once.\n\t\t\tconst hash: { [key: string]: boolean } = {};\n\t\t\tfor (let i = 0, numFaces = _exteriorFaces!.length; i < numFaces; i++) {\n\t\t\t\tconst faceIndices = _exteriorFaces![i];\n\t\t\t\t// For triangles, create an edge between each pair of indices in face.\n\t\t\t\tconst numNodes = faceIndices.length;\n\t\t\t\tfor (let j = 0; j < numNodes; j++) {\n\t\t\t\t\tfor (let k = j + 1; k < numNodes; k++) {\n\t\t\t\t\t\tif (j === k) continue;\n\t\t\t\t\t\tconst a = faceIndices[j];\n\t\t\t\t\t\tconst b = faceIndices[k];\n\t\t\t\t\t\tconst key = `${Math.min(a, b)},${Math.max(a, b)}`;\n\t\t\t\t\t\thash[key] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst keys = Object.keys(hash);\n\t\t\tconst edgesArray = new Uint32Array(keys.length * 2);\n\t\t\tfor (let i = 0, length = keys.length; i < length; i++) {\n\t\t\t\tconst indices = keys[i].split(',');\n\t\t\t\tedgesArray[2 * i] = parseInt(indices[0]);\n\t\t\t\tedgesArray[2 * i + 1] = parseInt(indices[1]);\n\t\t\t}\n\t\t\tthis._exteriorEdges = edgesArray;\n\t\t}\n\t\treturn this._exteriorEdges;\n\t}\n\n\tset exteriorEdges(exteriorEdges: Uint32Array) {\n\t\tthrow new Error(`msh-parser: No exteriorEdges setter.`);\n\t}\n\n\tget exteriorFaces() {\n\t\tif (!this.isTetMesh || !this._exteriorFaces) throw new Error(`msh-parser: MSHMesh.exteriorFaces is not defined for non-tet meshes.`);\n\t\treturn this._exteriorFaces;\n\t}\n\n\tset exteriorFaces(exteriorFaces: number[][]) {\n\t\tthrow new Error(`msh-parser: No exteriorFaces setter.`);\n\t}\n\n\tprivate static _tetrahedronVolume(indices: number[], nodesArray: Float32Array | Float64Array) {\n\t\tconst [a, b, c, d] = indices;\n\t\t// Calculate the vectors representing the edges of the tetrahedron.\n\t\tconst v1 = _MSHMesh._vecFromTo(d, a, nodesArray);\n\t\tconst v2 = _MSHMesh._vecFromTo(d, b, nodesArray);\n\t\tconst v3 = _MSHMesh._vecFromTo(d, c, nodesArray);\n\t  \n\t\t// Calculate the volume of the tetrahedron using the formula:\"\"\n\t\t// (1/6) * |v1 . (v2 x v3)|\n\t\t// https://en.wikipedia.org/wiki/Tetrahedron#Volume\n\t\treturn Math.abs(_MSHMesh._dotProduct(v1, _MSHMesh._crossProduct(v2, v3))) / 6;\n\t}\n\n\tget elementVolumes() {\n\t\tif (!this._elementVolumes) {\n\t\t\tconst { elements, nodes, isTetMesh } = this;\n\t\t\tif (!isTetMesh) throw new Error(`msh-parser: MSHMesh.elementVolumes is not defined for non-tet meshes.`);\n\t\t\tconst numElements = elements.length;\n\t\t\tconst volumes = new Float32Array(numElements);\n\t\t\tfor (let i = 0; i < numElements; i++) {\n\t\t\t\tvolumes[i] = _MSHMesh._tetrahedronVolume(elements[i], nodes);\n\t\t\t}\n\t\t\tthis._elementVolumes = volumes;\n\t\t}\n\t\treturn this._elementVolumes;\n\t}\n\n\tset elementVolumes(elementVolumes: Float32Array) {\n\t\tthrow new Error(`msh-parser: No elementVolumes setter.`);\n\t}\n\n\tget nodalVolumes() {\n\t\tif (!this._nodalVolumes) {\n\t\t\tconst { elements, nodes, isTetMesh } = this;\n\t\t\tif (!isTetMesh) throw new Error(`msh-parser: MSHMesh.nodalVolumes is not defined for non-tet meshes.`);\n\t\t\tconst { elementVolumes } = this;\n\t\t\tconst nodalVolumes = new Float32Array(nodes.length / 3);\n\t\t\tfor (let i = 0, numElements = elements.length; i < numElements; i++) {\n\t\t\t\tconst nodeIndices = elements[i];\n\t\t\t\tconst numNodeIndices = nodeIndices.length;\n\t\t\t\tfor (let j = 0; j < numNodeIndices; j++) {\n\t\t\t\t\tconst nodeIndex = nodeIndices[j];\n\t\t\t\t\t// Split element volume evenly across adjacent nodes.\n\t\t\t\t\tnodalVolumes[nodeIndex] += elementVolumes[i] / numNodeIndices;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._nodalVolumes = nodalVolumes;\n\t\t}\n\t\treturn this._nodalVolumes;\n\t}\n\n\tset nodalVolumes(nodalVolumes: Float32Array) {\n\t\tthrow new Error(`msh-parser: No nodalVolumes setter.`);\n\t}\n\n\tget numExteriorNodes() {\n\t\tif (!this.isTetMesh || !this._numExteriorNodes) throw new Error(`msh-parser: MSHMesh.numExteriorNodes is not defined for non-tet meshes.`);\n\t\treturn this._numExteriorNodes;\n\t}\n\n\tset numExteriorNodes(numExteriorNodes: number) {\n\t\tthrow new Error(`msh-parser: No numExteriorNodes setter.`);\n\t}\n\n\tget boundingBox() {\n\t\tif (!this._boundingBox) {\n\t\t\tconst { nodes } = this;\n\t\t\tconst numNodes = nodes.length / 3;\n\t\t\tconst min = [Infinity, Infinity, Infinity];\n\t\t\tconst max = [-Infinity, -Infinity, -Infinity];\n\t\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\t\tmin[0] = Math.min(min[0], nodes[3 * i]);\n\t\t\t\tmin[1] = Math.min(min[1], nodes[3 * i + 1]);\n\t\t\t\tmin[2] = Math.min(min[2], nodes[3 * i + 2]);\n\t\t\t\tmax[0] = Math.max(max[0], nodes[3 * i]);\n\t\t\t\tmax[1] = Math.max(max[1], nodes[3 * i + 1]);\n\t\t\t\tmax[2] = Math.max(max[2], nodes[3 * i + 2]);\n\t\t\t}\n\t\t\tthis._boundingBox = {\n\t\t\t\tmin, max,\n\t\t\t};\n\t\t}\n\t\treturn this._boundingBox;\n\t}\n\n\tset boundingBox(boundingBox: { min: number[], max: number[] }) {\n\t\tthrow new Error(`msh-parser: No boundingBox setter.`);\n\t}\n\n\t/**\n\t * Scales nodes to unit bounding box and centers around origin.\n\t */\n\tscaleNodesToUnitBoundingBox() {\n\t\tconst { nodes, boundingBox } = this;\n\t\tconst { min, max } = boundingBox;\n\t\tconst diff = [max[0] - min[0], max[1] - min[1], max[2] - min[2]];\n\t\tconst center = [(max[0] + min[0]) / 2, (max[1] + min[1]) / 2, (max[2] + min[2]) / 2];\n\t\tconst scale = Math.max(diff[0], diff[1], diff[2]);\n\t\tconst numNodes = nodes.length / 3;\n\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\tfor (let j = 0; j < 3; j++) {\n\t\t\t\t// Uniform scale.\n\t\t\t\tnodes[3 * i + j] = (nodes[3 * i + j] - center[j]) / scale;\n\t\t\t}\n\t\t}\n\t\tdelete this._boundingBox;\n\t\tdelete this._nodalVolumes;\n\t\tdelete this._elementVolumes;\n\t\treturn this;\n\t}\n}\n"],"names":["parseMsh","data","_MSHMesh","loadMsh","urlOrFile","callback","window","request","XMLHttpRequest","open","responseType","onload","mesh","response","send","import","then","fs","buffer","readFileSync","reader","FileReader","result","readAsArrayBuffer","constructor","this","_offset","arrayBuffer","Uint8Array","dataView","DataView","uint8Array","_parseNextLineAsUTF8","_throwInvalidFormatError","version","type","dataSize","split","map","el","parseFloat","isNaN","Error","doublePrecision","isBinary","isLE","getInt32","numNodes","parseInt","nodesArray","Float64Array","Float32Array","i","index","getFloat64","getFloat32","length","_isFiniteNumber","_nodes","numElements","elementsArray","push","elements","isTetMesh","elementIndex","tagWarning","elementType","elementNumElements","elementNumTags","numElementNodes","_numNodesPerElementType","j","console","warn","nodeIndices","nodeIndex","hash","indices","key","_makeTriHash","keys","Object","exteriorFacesArray","exteriorNodes","numKeys","a","b","c","d","orientation","_dotProduct","_crossProduct","_vecFromTo","currentIndex","newIndices","Int32Array","_numExteriorNodes","newNodesArray","slice","_exteriorFaces","nodes","newlineIndex","indexOf","text","decoder","decode","subarray","static","number","Infinity","vector1","vector2","from","to","min","Math","max","edges","_edges","elementIndices","k","edgesArray","Uint32Array","exteriorEdges","_exteriorEdges","numFaces","faceIndices","exteriorFaces","v1","v2","v3","abs","elementVolumes","_elementVolumes","volumes","_tetrahedronVolume","nodalVolumes","_nodalVolumes","numNodeIndices","numExteriorNodes","boundingBox","_boundingBox","scaleNodesToUnitBoundingBox","diff","center","scale","TextDecoder","Promise","resolve"],"mappings":"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"}