{"version":3,"file":"msh-parser.min.js","sources":["../node_modules/@amandaghassaei/3d-mesh-utils/dist/index-utils.js","../src/msh-parser.ts","../node_modules/@amandaghassaei/3d-mesh-utils/dist/geometry-utils.js"],"sourcesContent":["/**\n * Make hash key for edge.\n * @param index1 - Index of first vertex.\n * @param index2 - Index of second vertex.\n * @returns - Hash key for edge.\n */\nexport function makeEdgeHash(index1, index2) {\n    return `${Math.min(index1, index2)},${Math.max(index1, index2)}`;\n}\n/**\n * Make hash key for triangle face.\n * @param index1 - Index of first vertex.\n * @param index2 - Index of second vertex.\n * @param index3 - Index of third vertex.\n * @returns - Hash key for triangle face.\n */\nexport function makeTriangleFaceHash(index1, index2, index3) {\n    const min = Math.min(index1, index2, index3);\n    const max = Math.max(index1, index2, index3);\n    const sum = index1 + index2 + index3;\n    return `${min},${sum - min - max},${max}`;\n}\nlet tempArray = [];\n/**\n * Make hash key for face with any number of vertices.\n * @param faceIndices - Array of vertex indices.\n * @returns - Hash key for face.\n */\nexport function makeFaceHash(faceIndices) {\n    const length = faceIndices.length;\n    tempArray.length = length;\n    for (let i = 0; i < length; i++) {\n        tempArray[i] = faceIndices[i];\n    }\n    tempArray.sort((a, b) => (a - b));\n    return tempArray.join(',');\n}\n//# sourceMappingURL=index-utils.js.map","import {\n\tcalcBoundingBox,\n\tscaleVerticesToUnitBoundingBox,\n\tcalcEdgeIndicesFromNestedIndexedFaces,\n\tmakeEdgeHash,\n\tmakeTriangleFaceHash,\n} from '@amandaghassaei/3d-mesh-utils';\n\n/**\n * Synchronously parse an already loaded .msh file buffer.\n */\nexport function parseMSH(data: Buffer | ArrayBuffer): MSHMesh {\n\treturn new _MSHMesh(data);\n}\n/**\n * Load and parse .msh asynchronously from the specified url or File object (returns Promise).\n */\nexport function loadMSHAsync(urlOrFile: string | File) {\n\treturn new Promise<MSHMesh>((resolve) => {\n\t\tloadMSH(urlOrFile, (mesh) => {\n\t\t\tresolve(mesh);\n\t\t});\n\t});\n}\n\n/**\n * Load and parse .msh from the specified url or File object.\n */\nexport function loadMSH(urlOrFile: string | File, callback: (mesh: MSHMesh) => void) {\n\tif (typeof urlOrFile === 'string') {\n\t\t// Made this compatible with Node and the browser, maybe there is a better way?\n\t\t/* c8 ignore start */\n\t\tif (typeof window !== 'undefined') {\n\t\t\t// Browser.\n\t\t\t// Load the file with XMLHttpRequest.\n\t\t\tconst request = new XMLHttpRequest();\n\t\t\trequest.open('GET', urlOrFile, true);\n\t\t\trequest.responseType = 'arraybuffer';\n\t\t\trequest.onload = () => {\n\t\t\t\tconst mesh = parseMSH(request.response as ArrayBuffer);\n\t\t\t\t// Call the callback function with the parsed mesh data.\n\t\t\t\tcallback(mesh);\n\t\t\t};\n\t\t\trequest.send();\n\t\t/* c8 ignore stop */\n\t\t} else {\n\t\t\t// Call the callback function with the parsed mesh data.\n\t\t\timport('fs').then((fs) => {\n\t\t\t\tconst buffer = fs.readFileSync(urlOrFile);\n\t\t\t\tcallback(parseMSH(buffer));\n\t\t\t});\n\t\t}\n\t/* c8 ignore start */\n\t} else {\n\t\t// We only ever hit this in the browser.\n\t\t// Load the file with FileReader.\n\t\tconst reader = new FileReader();\n\t\treader.onload = () => {\n\t\t\tconst mesh = parseMSH(reader.result as ArrayBuffer);\n\t\t\t// Call the callback function with the parsed mesh data.\n\t\t\tcallback(mesh);\n\t\t}\n\t\treader.readAsArrayBuffer(urlOrFile);\n\t}\n\t/* c8 ignore stop */\n}\n\n// Export just the type, keep the class private.\nexport type MSHMesh = {\n\treadonly nodes: Float64Array | Float32Array;\n\treadonly nodalVolumes: Float32Array;\n\treadonly elementIndices: number[][];\n\treadonly elementVolumes: Float32Array;\n\treadonly edgeIndices: Uint32Array;\n\treadonly exteriorEdgeIndices: Uint32Array;\n\treadonly exteriorFaceIndices: number[][];\n\treadonly isTetMesh: boolean;\n\treadonly numExteriorNodes: number;\n\treadonly boundingBox: { min: number[], max: number[] };\n\tscaleNodesToUnitBoundingBox: () => MSHMesh;\n}\n\n// Based on: https://github.com/PyMesh/PyMesh/blob/main/src/IO/MshLoader.cpp\n// Define the MSHMesh class.\nclass _MSHMesh {\n\t// TextDecoder instance to decode the header as UTF-8.\n\tstatic decoder = new TextDecoder();\n\t// Header offset.\n\tprivate _offset = 0;\n\n\tprivate _nodes: Float64Array | Float32Array;\n\treadonly elementIndices: number[][];\n\tprivate _edgeIndices?: Uint32Array;\n\tprivate _exteriorEdgeIndices?: Uint32Array;\n\tprivate _elementVolumes?: Float32Array;\n\tprivate _nodalVolumes?: Float32Array;\n\tprivate _boundingBox?: { min: [number, number, number], max: [number, number, number] };\n\treadonly isTetMesh: boolean;\n\tprivate readonly _exteriorFaceIndices?: number[][];\n\tprivate readonly _numExteriorNodes?: number;\n\n\tconstructor(data: ArrayBuffer | Buffer) {\n\t\tconst arrayBuffer = (data as Buffer).buffer ? new Uint8Array(data as Buffer).buffer : data;\n\t\tconst dataView = new DataView(arrayBuffer);\n\t\t// Create a Uint8Array that references the same underlying memory as the DataView.\n\t\tconst uint8Array = new Uint8Array(dataView.buffer);\n\n\t\t// Parse header.\n\t\t/* c8 ignore next */\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$MeshFormat') _MSHMesh._throwInvalidFormatError();\n\t\tconst [ version, type, dataSize ] = this._parseNextLineAsUTF8(uint8Array).split(' ').map(el => parseFloat(el));\n\t\t/* c8 ignore next */\n\t\tif (isNaN(version) || isNaN(type) || isNaN(dataSize)) _MSHMesh._throwInvalidFormatError();\n\t\t/* c8 ignore next */\n\t\tif (dataSize !== 8 && dataSize !== 4) throw new Error(`msh-parser: This library currently parses .msh files with data size === 8 or 4.  Current file has data size = ${dataSize}. Please submit an issue to the GitHub repo if you encounter this error and attach a sample file.`);\n\t\tconst doublePrecision = dataSize === 8;\n\t\tconst isBinary = type === 1;\n\t\tlet isLE = false;\n\t\tif (isBinary) {\n\t\t\t// Read in extra info from binary header.\n\t\t\t// TODO: how do we know to read as LE here?\n\t\t\tif (dataView.getInt32(this._offset, true) === 1) {\n\t\t\t\t// Read as LE.\n\t\t\t\tisLE = true;\n\t\t\t}\n\t\t\tthis._offset += 4;\n\t\t}\n\t\t/* c8 ignore next */\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$EndMeshFormat') _MSHMesh._throwInvalidFormatError();\n\n\t\t// Read the number of nodes.\n\t\t/* c8 ignore next */\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$Nodes') _MSHMesh._throwInvalidFormatError();\n\t\tconst numNodes = parseInt(this._parseNextLineAsUTF8(uint8Array));\n\t\t// Loop through the nodes.\n\t\tconst nodesArray = doublePrecision ? new Float64Array(3 * numNodes) : new Float32Array(3 * numNodes);\n\t\tif (isBinary) {\n\t\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\t\t// Read the current node.\n\t\t\t\tconst index = dataView.getInt32(this._offset, isLE) - 1; // The .msh node index is 1-indexed.\n\t\t\t\tif (doublePrecision) {\n\t\t\t\t\tnodesArray[3 * index] = dataView.getFloat64(this._offset + 4, isLE);\n\t\t\t\t\tnodesArray[3 * index + 1] = dataView.getFloat64(this._offset + 4 + dataSize, isLE);\n\t\t\t\t\tnodesArray[3 * index + 2] = dataView.getFloat64(this._offset + 4 + 2 * dataSize, isLE);\n\t\t\t\t} else {\n\t\t\t\t\tnodesArray[3 * index] = dataView.getFloat32(this._offset + 4, isLE);\n\t\t\t\t\tnodesArray[3 * index + 1] = dataView.getFloat32(this._offset + 4 + dataSize, isLE);\n\t\t\t\t\tnodesArray[3 * index + 2] = dataView.getFloat32(this._offset + 4 + 2 * dataSize, isLE);\n\t\t\t\t}\n\t\t\t\t// Update the current file's byte offset.\n\t\t\t\tthis._offset += 4 + 3 * dataSize;\n\t\t\t}\n\t\t/* c8 ignore next 3 */\n\t\t} else {\n\t\t\tthrow new Error('msh-parser: This library does not currently parse non-binary .msh files.  Please submit an issue to the GitHub repo if you encounter this error and attach a sample file.');\n\t\t}\n\t\t// Check that all nodes are finite.\n\t\tfor (let i = 0; i < nodesArray.length; i++) {\n\t\t\t/* c8 ignore next */\n\t\t\tif (!_MSHMesh._isFiniteNumber(nodesArray[i])) throw new Error('msh-parser: NaN or Inf detected in input file.');\n\t\t}\n\t\t/* c8 ignore next */\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$EndNodes') _MSHMesh._throwInvalidFormatError();\n\t\tthis._nodes = nodesArray;\n\n\t\t/* c8 ignore next */\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$Elements') _MSHMesh._throwInvalidFormatError();\n\n\t\t// Read the number of elementIndices.\n\t\tconst numElements = parseInt(this._parseNextLineAsUTF8(uint8Array));\n\t\tconst elementsArray: number[][] = [];\n\t\tfor (let i = 0; i < numElements; i++) {\n\t\t\telementsArray.push([]);\n\t\t}\n\t\tthis.elementIndices = elementsArray;\n\n\t\t// Check if all elementIndices are tetrahedra.\n\t\tlet isTetMesh = true;\n\t\t// Loop through the elementIndices.\n\t\tlet elementIndex = 0;\n\t\tlet tagWarning = false;\n\t\tif (isBinary) {\n\t\t\twhile (elementIndex < numElements) {\n\t\t\t\t// Parse element header.\n\t\t\t\tconst elementType = dataView.getInt32(this._offset, isLE);\n\t\t\t\tconst elementNumElements = dataView.getInt32(this._offset + 4, isLE);\n\t\t\t\tconst elementNumTags = dataView.getInt32(this._offset + 8, isLE);\n\t\t\t\t/* c8 ignore next */\n\t\t\t\tif (elementType !== 4) isTetMesh = false;\n\t\t\t\tconst numElementNodes = _MSHMesh._numNodesPerElementType(elementType);\n\t\t\t\t// Update the current file's byte offset.\n\t\t\t\tthis._offset += 12;\n\t\t\t\tfor (let i = 0; i < elementNumElements; i++) {\n\t\t\t\t\tconst index = dataView.getInt32(this._offset, isLE) - 1; // The .msh index is 1-indexed.\n\t\t\t\t\t/* c8 ignore next */\n\t\t\t\t\tif (index < 0 || index >= numElements) throw new Error(`msh-parser: Invalid element index ${index} for numElements === ${numElements}.`);\n\t\t\t\t\tthis._offset += 4;\n\t\t\t\t\t/* c8 ignore start */\n\t\t\t\t\tfor (let j = 0; j < elementNumTags; j++) {\n\t\t\t\t\t\t// const tag = dataView.getInt32(this._offset, isLE);\n\t\t\t\t\t\tif (!tagWarning) {\n\t\t\t\t\t\t\ttagWarning = true;\n\t\t\t\t\t\t\tconsole.warn('msh-parser: This library does not currently parse element tags.');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Update the current file's byte offset.\n\t\t\t\t\t\tthis._offset += 4;\n\t\t\t\t\t}\n\t\t\t\t\t/* c8 ignore stop */\n\t\t\t\t\t\n\t\t\t\t\tconst nodeIndices = elementsArray[index];\n\t\t\t\t\tfor (let j = 0; j < numElementNodes; j++) {\n\t\t\t\t\t\tconst nodeIndex = dataView.getInt32(this._offset, isLE) - 1; // The .msh index is 1-indexed.\n\t\t\t\t\t\t/* c8 ignore next */\n\t\t\t\t\t\tif (!_MSHMesh._isFiniteNumber(nodeIndex)) throw new Error('msh-parser: NaN or Inf detected in input file.');\n\t\t\t\t\t\t/* c8 ignore next */\n\t\t\t\t\t\tif (nodeIndex < 0 || nodeIndex >= numNodes) throw new Error(`msh-parser: Invalid node index ${nodeIndex} for numNodes === ${numNodes}.`);\n\t\t\t\t\t\tnodeIndices.push(nodeIndex);\n\t\t\t\t\t\t// Update the current file's byte offset.\n\t\t\t\t\t\tthis._offset += 4;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telementIndex += elementNumElements;\n\t\t\t}\n\t\t/* c8 ignore next 3 */\n\t\t} else {\n\t\t\tthrow new Error('msh-parser: This library does not currently parse non-binary .msh files.  Please submit an issue to the GitHub repo if you encounter this error and attach a sample file.');\n\t\t}\n\t\t/* c8 ignore next */\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$EndElements') _MSHMesh._throwInvalidFormatError();\n\n\t\tthis.isTetMesh = isTetMesh;\n\t\t// TODO: make this work for non-tet.\n\t\tif (isTetMesh) {\n\t\t\t// For tet meshes, calculate exterior faces.\n\t\t\t// First find all faces that are covered only once, these are on the boundary.\n\t\t\tconst hash: { [key: string]: number[] } = {};\n\t\t\tfor (let i = 0; i < numElements; i++) {\n\t\t\t\tconst indices = elementsArray[i];\n\t\t\t\tfor (let j = 0; j < indices.length; j++) {\n\t\t\t\t\tconst key = makeTriangleFaceHash(indices[j], indices[(j + 1) % 4], indices[(j + 2) % 4]);\n\t\t\t\t\tif (hash[key]) {\n\t\t\t\t\t\thash[key].push(indices[(j + 3) % indices.length]);\n\t\t\t\t\t\t/* c8 ignore next 3 */\n\t\t\t\t\t\tif (hash[key].length > 2) {\n\t\t\t\t\t\t\tthrow new Error(`msh-parser: Hit face ${key} more than twice.`);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\thash[key] = [indices[(j + 3) % 4]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst keys = Object.keys(hash);\n\t\t\tconst exteriorFacesArray: number[][] = [];\n\t\t\tconst exteriorNodes = new Uint8Array(numNodes);\n\t\t\tfor (let i = 0, numKeys = keys.length; i < numKeys; i++) {\n\t\t\t\tconst key = keys[i];\n\t\t\t\tif (hash[key].length !== 1) continue;\n\t\t\t\tconst indices = keys[i].split(',');\n\t\t\t\tconst a = parseInt(indices[0]);\n\t\t\t\tconst b = parseInt(indices[1]);\n\t\t\t\tconst c = parseInt(indices[2]);\n\t\t\t\t// d is the internal node of this tet.\n\t\t\t\tconst d = hash[key][0];\n\t\t\t\t// Use d to calculate the winding order of the triangle.\n\t\t\t\tconst orientation = _MSHMesh._dotProduct(_MSHMesh._crossProduct(\n\t\t\t\t\t_MSHMesh._vecFromTo(a, b, nodesArray),\n\t\t\t\t\t_MSHMesh._vecFromTo(a, c, nodesArray),\n\t\t\t\t), _MSHMesh._vecFromTo(a, d, nodesArray));\n\t\t\t\texteriorFacesArray.push(orientation < 0 ? [a, b, c] : [a, c, b]);\n\t\t\t\t// Mark all nodes as exterior.\n\t\t\t\texteriorNodes[a] = 1;\n\t\t\t\texteriorNodes[b] = 1;\n\t\t\t\texteriorNodes[c] = 1;\n\t\t\t}\n\t\t\t\n\t\t\t// Also reorder the nodes so that the exterior nodes are first.\n\t\t\tlet currentIndex = 0;\n\t\t\tconst newIndices = new Int32Array(numNodes);\n\t\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\t\tif (exteriorNodes[i]) {\n\t\t\t\t\tnewIndices[i] = currentIndex;\n\t\t\t\t\tcurrentIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._numExteriorNodes = currentIndex;\n\t\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\t\tif (!exteriorNodes[i]) {\n\t\t\t\t\tnewIndices[i] = currentIndex;\n\t\t\t\t\tcurrentIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Now that we have a mapping, update nodesArrays, elementsArray, and exteriorFacesArray.\n\t\t\tconst newNodesArray = nodesArray.slice();\n\t\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\t\tfor (let j = 0; j < 3; j++) {\n\t\t\t\t\tnewNodesArray[3 * newIndices[i] + j] = nodesArray[3 * i + j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._nodes = newNodesArray;\n\t\t\tfor (let i = 0; i < numElements; i++) {\n\t\t\t\tconst indices = elementsArray[i];\n\t\t\t\tfor (let j = 0; j < indices.length; j++) {\n\t\t\t\t\tindices[j] = newIndices[indices[j]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i = 0; i < exteriorFacesArray.length; i++) {\n\t\t\t\tconst indices = exteriorFacesArray[i];\n\t\t\t\tfor (let j = 0; j < indices.length; j++) {\n\t\t\t\t\tindices[j] = newIndices[indices[j]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._exteriorFaceIndices = exteriorFacesArray;\n\t\t}\n\t}\n\n\tget nodes() {\n\t\treturn this._nodes;\n\t}\n\n\tset nodes(nodes: Float32Array | Float64Array) {\n\t\tthrow new Error(`msh-parser: No nodes setter.`);\n\t}\n\n\tprivate _parseNextLineAsUTF8(uint8Array: Uint8Array) {\n\t\t// Find the first newline character in the uint8Array.\n\t\tconst newlineIndex = uint8Array.indexOf(10, this._offset); // 10 is the ASCII code for the newline character.\n\t\t// Decode the uint8Array as a UTF-8 encoded string up until the newline character.\n\t\tconst text = _MSHMesh.decoder.decode(uint8Array.subarray(this._offset, newlineIndex));\n\t\t// Update offset.\n\t\tthis._offset = newlineIndex + 1;\n\t\t// Return the decoded string.\n\t\treturn text;\n\t}\n\n\t/* c8 ignore next 3 */\n\tprivate static _throwInvalidFormatError() {\n\t\tthrow new Error('msh-parser: Invalid .msh file format.');\n\t}\n\n\tprivate static _isFiniteNumber(number: number) {\n\t\treturn !isNaN(number) && number !== Infinity && number !== -Infinity;\n\t}\n\n\tprivate static _numNodesPerElementType(elementType: number) {\n\t\tswitch (elementType) {\n\t\t\tcase 2:\n\t\t\t\treturn 3; // Triangle\n\t\t\tcase 3:\n\t\t\t\treturn 4; // Quad\n\t\t\tcase 4:\n\t\t\t\treturn 4; // Tetrahedron\n\t\t\tcase 5:\n\t\t\t\treturn 8; // Hexahedron\n\t\t\t/* c8 ignore next 2 */\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`msh-parser: Element type ${elementType} is not supported yet.`);\n\t\t}\n\t}\n\t\n\t// Calculates the dot product of two vectors.\n\tprivate static _dotProduct(vector1: number[], vector2: number[]) {\n\t\treturn vector1[0] * vector2[0] + vector1[1] * vector2[1] + vector1[2] * vector2[2];\n\t}\n\t\n\t// Calculates the cross product of two vectors.\n\tprivate static _crossProduct(vector1: number[], vector2: number[]) {\n\t\treturn [\n\t\t\tvector1[1] * vector2[2] - vector1[2] * vector2[1],\n\t\t\tvector1[2] * vector2[0] - vector1[0] * vector2[2],\n\t\t\tvector1[0] * vector2[1] - vector1[1] * vector2[0]\n\t\t];\n\t}\n\n\tprivate static _vecFromTo(from: number, to: number, nodesArray: Float32Array | Float64Array) {\n\t\treturn [\n\t\t\tnodesArray[3 * to] - nodesArray[3 * from],\n\t\t\tnodesArray[3 * to + 1] - nodesArray[3 * from + 1],\n\t\t\tnodesArray[3 * to + 2] - nodesArray[3 * from + 2],\n\t\t];\n\t}\n\n\tget edgeIndices() {\n\t\tif (!this._edgeIndices) {\n\t\t\tconst { elementIndices, isTetMesh } = this;\n\t\t\t/* c8 ignore next */\n\t\t\tif (!isTetMesh) throw new Error(`msh-parser: MSHMesh.edgeIndices is not defined for non-tet meshes.`);\n\t\t\t// Calc all edgeIndices in mesh, use hash table to cover each edge only once.\n\t\t\tconst edgeIndicesHash: { [key: string]: boolean } = {};\n\t\t\tconst edgeIndices: number[] = [];\n\t\t\tfor (let i = 0, numElements = elementIndices.length; i < numElements; i++) {\n\t\t\t\tconst element = elementIndices[i];\n\t\t\t\t// For tetrahedra, create an edge between each pair of nodes in element.\n\t\t\t\tconst numNodes = element.length;\n\t\t\t\tfor (let j = 0; j < numNodes; j++) {\n\t\t\t\t\tfor (let k = j + 1; k < numNodes; k++) {\n\t\t\t\t\t\tconst a = element[j];\n\t\t\t\t\t\tconst b = element[k];\n\t\t\t\t\t\tconst key = makeEdgeHash(a, b);\n\t\t\t\t\t\t// Only add each edge once.\n\t\t\t\t\t\tif (edgeIndicesHash[key] === undefined) {\n\t\t\t\t\t\t\tedgeIndicesHash[key] = true;\n\t\t\t\t\t\t\tedgeIndices.push(a, b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._edgeIndices = new Uint32Array(edgeIndices);;\n\t\t}\n\t\treturn this._edgeIndices;\n\t}\n\n\tset edgeIndices(edgeIndices: Uint32Array) {\n\t\tthrow new Error(`msh-parser: No edgeIndices setter.`);\n\t}\n\n\tget exteriorEdgeIndices() {\n\t\tif (!this._exteriorEdgeIndices) {\n\t\t\tconst { isTetMesh, _exteriorFaceIndices } = this;\n\t\t\t/* c8 ignore next */\n\t\t\tif (!isTetMesh) throw new Error(`msh-parser: MSHMesh.exteriorEdgeIndices is not defined for non-tet meshes.`);\n\t\t\tconst edgeIndices = calcEdgeIndicesFromNestedIndexedFaces({ faceIndices: _exteriorFaceIndices! })\n\t\t\tthis._exteriorEdgeIndices = new Uint32Array(edgeIndices);\n\t\t}\n\t\treturn this._exteriorEdgeIndices;\n\t}\n\n\tset exteriorEdgeIndices(exteriorEdgeIndices: Uint32Array) {\n\t\tthrow new Error(`msh-parser: No exteriorEdgeIndices setter.`);\n\t}\n\n\tget exteriorFaceIndices() {\n\t\t/* c8 ignore next */\n\t\tif (!this.isTetMesh || !this._exteriorFaceIndices) throw new Error(`msh-parser: MSHMesh.exteriorFaceIndices is not defined for non-tet meshes.`);\n\t\treturn this._exteriorFaceIndices;\n\t}\n\n\tset exteriorFaceIndices(exteriorFaceIndices: number[][]) {\n\t\tthrow new Error(`msh-parser: No exteriorFaceIndices setter.`);\n\t}\n\n\tprivate static _tetrahedronVolume(indices: number[], nodesArray: Float32Array | Float64Array) {\n\t\tconst [a, b, c, d] = indices;\n\t\t// Calculate the vectors representing the edgeIndices of the tetrahedron.\n\t\tconst v1 = _MSHMesh._vecFromTo(d, a, nodesArray);\n\t\tconst v2 = _MSHMesh._vecFromTo(d, b, nodesArray);\n\t\tconst v3 = _MSHMesh._vecFromTo(d, c, nodesArray);\n\t  \n\t\t// Calculate the volume of the tetrahedron using the formula:\"\"\n\t\t// (1/6) * |v1 . (v2 x v3)|\n\t\t// https://en.wikipedia.org/wiki/Tetrahedron#Volume\n\t\treturn Math.abs(_MSHMesh._dotProduct(v1, _MSHMesh._crossProduct(v2, v3))) / 6;\n\t}\n\n\tget elementVolumes() {\n\t\tif (!this._elementVolumes) {\n\t\t\tconst { elementIndices, nodes, isTetMesh } = this;\n\t\t\t/* c8 ignore next */\n\t\t\tif (!isTetMesh) throw new Error(`msh-parser: MSHMesh.elementVolumes is not defined for non-tet meshes.`);\n\t\t\tconst numElements = elementIndices.length;\n\t\t\tconst volumes = new Float32Array(numElements);\n\t\t\tfor (let i = 0; i < numElements; i++) {\n\t\t\t\tvolumes[i] = _MSHMesh._tetrahedronVolume(elementIndices[i], nodes);\n\t\t\t}\n\t\t\tthis._elementVolumes = volumes;\n\t\t}\n\t\treturn this._elementVolumes;\n\t}\n\n\tset elementVolumes(elementVolumes: Float32Array) {\n\t\tthrow new Error(`msh-parser: No elementVolumes setter.`);\n\t}\n\n\tget nodalVolumes() {\n\t\tif (!this._nodalVolumes) {\n\t\t\tconst { elementIndices, nodes, isTetMesh } = this;\n\t\t\t/* c8 ignore next */\n\t\t\tif (!isTetMesh) throw new Error(`msh-parser: MSHMesh.nodalVolumes is not defined for non-tet meshes.`);\n\t\t\tconst { elementVolumes } = this;\n\t\t\tconst nodalVolumes = new Float32Array(nodes.length / 3);\n\t\t\tfor (let i = 0, numElements = elementIndices.length; i < numElements; i++) {\n\t\t\t\tconst nodeIndices = elementIndices[i];\n\t\t\t\tconst numNodeIndices = nodeIndices.length;\n\t\t\t\tfor (let j = 0; j < numNodeIndices; j++) {\n\t\t\t\t\tconst nodeIndex = nodeIndices[j];\n\t\t\t\t\t// Split element volume evenly across adjacent nodes.\n\t\t\t\t\tnodalVolumes[nodeIndex] += elementVolumes[i] / numNodeIndices;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._nodalVolumes = nodalVolumes;\n\t\t}\n\t\treturn this._nodalVolumes;\n\t}\n\n\tset nodalVolumes(nodalVolumes: Float32Array) {\n\t\tthrow new Error(`msh-parser: No nodalVolumes setter.`);\n\t}\n\n\tget numExteriorNodes() {\n\t\t/* c8 ignore next */\n\t\tif (!this.isTetMesh || !this._numExteriorNodes) throw new Error(`msh-parser: MSHMesh.numExteriorNodes is not defined for non-tet meshes.`);\n\t\treturn this._numExteriorNodes;\n\t}\n\n\tset numExteriorNodes(numExteriorNodes: number) {\n\t\tthrow new Error(`msh-parser: No numExteriorNodes setter.`);\n\t}\n\n\tget boundingBox() {\n\t\tif (!this._boundingBox) {\n\t\t\tthis._boundingBox = calcBoundingBox({\n\t\t\t\tvertices: this.nodes,\n\t\t\t});\n\t\t}\n\t\treturn this._boundingBox;\n\t}\n\n\tset boundingBox(boundingBox: { min: [number, number, number], max: [number, number, number] }) {\n\t\tthrow new Error(`msh-parser: No boundingBox setter.`);\n\t}\n\n\t/**\n\t * Scales nodes to unit bounding box and centers around origin.\n\t */\n\tscaleNodesToUnitBoundingBox() {\n\t\tscaleVerticesToUnitBoundingBox({\n\t\t\tvertices: this.nodes,\n\t\t\tboundingBox: this.boundingBox,\n\t\t});\n\t\tdelete this._boundingBox;\n\t\tdelete this._nodalVolumes;\n\t\tdelete this._elementVolumes;\n\t\treturn this;\n\t}\n}\n","import { makeEdgeHash } from './index-utils';\n/**\n * Returns the bounding box of the mesh.\n */\nexport function calcBoundingBox(mesh) {\n    const { vertices } = mesh;\n    const numVertices = vertices.length / 3;\n    const min = [Infinity, Infinity, Infinity];\n    const max = [-Infinity, -Infinity, -Infinity];\n    for (let i = 0; i < numVertices; i++) {\n        min[0] = Math.min(min[0], vertices[3 * i]);\n        min[1] = Math.min(min[1], vertices[3 * i + 1]);\n        min[2] = Math.min(min[2], vertices[3 * i + 2]);\n        max[0] = Math.max(max[0], vertices[3 * i]);\n        max[1] = Math.max(max[1], vertices[3 * i + 1]);\n        max[2] = Math.max(max[2], vertices[3 * i + 2]);\n    }\n    return { min, max };\n}\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh contains indexed faces.\n * Vertices are grouped into faces of any size: [[f01, f0b, f0c], [f1a, f1b, f1c, f1d], ...]\n */\nexport function calcEdgeIndicesFromNestedIndexedFaces(mesh) {\n    const { faceIndices } = mesh;\n    // Handle edges on indexed faces.\n    const numFaces = faceIndices.length;\n    // Use hash to calc edges.\n    const edgesHash = {};\n    const edges = [];\n    for (let i = 0; i < numFaces; i++) {\n        const face = faceIndices[i];\n        const numVertices = face.length;\n        for (let j = 0; j < numVertices; j++) {\n            const index1 = face[j];\n            const index2 = face[(j + 1) % numVertices];\n            const key = makeEdgeHash(index1, index2);\n            // Only add each edge once.\n            if (edgesHash[key] === undefined) {\n                edgesHash[key] = true;\n                edges.push(index1, index2);\n            }\n        }\n    }\n    return edges;\n}\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh contains indexed faces.\n * Assumes flat list of triangle faces: [f0a, f0b, f0c, f1a, f1b, f1c, ...]\n */\nexport function calcEdgeIndicesFromIndexedFaces(mesh) {\n    const { faceIndices } = mesh;\n    // Handle edges on indexed faces.\n    const numFaces = faceIndices.length / 3;\n    // Use hash to calc edges.\n    const edgesHash = {};\n    const edges = [];\n    for (let i = 0; i < numFaces; i++) {\n        for (let j = 0; j < 3; j++) {\n            const index1 = faceIndices[3 * i + j];\n            const index2 = faceIndices[3 * i + (j + 1) % 3];\n            const key = makeEdgeHash(index1, index2);\n            // Only add each edge once.\n            if (edgesHash[key] === undefined) {\n                edgesHash[key] = true;\n                edges.push(index1, index2);\n            }\n        }\n    }\n    return edges;\n}\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh vertices are groups in sets of three to a face (triangle mesh).\n */\nexport function calcEdgeIndicesFromNonIndexedFaces(mesh) {\n    const { vertices } = mesh;\n    const numVertices = vertices.length / 3;\n    // Vertices are grouped in sets of three to a face.\n    const numFaces = numVertices / 3;\n    const edges = new Uint32Array(6 * numFaces);\n    for (let i = 0; i < numFaces; i++) {\n        const index = 3 * i;\n        for (let j = 0; j < 3; j++) {\n            const edgeIndex = 6 * i + 2 * j;\n            edges[edgeIndex] = index + j;\n            edges[edgeIndex + 1] = index + (j + 1) % 3;\n        }\n    }\n    return edges;\n}\n/**\n * Scales vertex positions (in place, unless target provided) to unit bounding box and centers around origin.\n * Assumes all vertex positions are used in mesh.\n */\nexport function scaleVerticesToUnitBoundingBox(mesh, target = mesh.vertices) {\n    const { vertices, boundingBox } = mesh;\n    const { min, max } = boundingBox;\n    const diff = [max[0] - min[0], max[1] - min[1], max[2] - min[2]];\n    const center = [(max[0] + min[0]) / 2, (max[1] + min[1]) / 2, (max[2] + min[2]) / 2];\n    const scale = Math.max(diff[0], diff[1], diff[2]);\n    const numNodes = vertices.length / 3;\n    for (let i = 0; i < numNodes; i++) {\n        for (let j = 0; j < 3; j++) {\n            // Uniform scale.\n            target[3 * i + j] = (vertices[3 * i + j] - center[j]) / scale;\n        }\n    }\n}\n/**\n * Merge coincident vertices and index faces.\n */\nexport function mergeVertices(mesh) {\n    const { vertices, uvs, vertexNormals, vertexColors } = mesh;\n    const numFaces = vertices.length / 9;\n    const previousIndexMap = []; // Map from old vertex index to new vertex index.\n    const facesIndexed = new Uint32Array(numFaces * 3);\n    // Use hash to merge vertices.\n    const vertexHash = {};\n    for (let i = 0; i < numFaces; i++) {\n        for (let j = 0; j < 3; j++) {\n            const vertexIndex = 3 * i + j;\n            const positionX = vertices[3 * vertexIndex];\n            const positionY = vertices[3 * vertexIndex + 1];\n            const positionZ = vertices[3 * vertexIndex + 2];\n            let key = `${positionX},${positionY},${positionZ}`;\n            if (uvs) {\n                const uvX = uvs[2 * vertexIndex];\n                const uvY = uvs[2 * vertexIndex + 1];\n                key += `|${uvX},${uvY}`;\n            }\n            if (vertexNormals) {\n                const normalX = vertexNormals[3 * vertexIndex];\n                const normalY = vertexNormals[3 * vertexIndex + 1];\n                const normalZ = vertexNormals[3 * vertexIndex + 2];\n                key += `|${normalX},${normalY},${normalZ}`;\n            }\n            if (vertexColors) {\n                const colorR = vertexColors[3 * vertexIndex];\n                const colorG = vertexColors[3 * vertexIndex + 1];\n                const colorB = vertexColors[3 * vertexIndex + 2];\n                key += `|${colorR},${colorG},${colorB}`;\n            }\n            const faceIndex = 3 * i;\n            let mergedVertexIndex = vertexHash[key];\n            if (mergedVertexIndex !== undefined) {\n                facesIndexed[faceIndex + j] = mergedVertexIndex;\n            }\n            else {\n                // Add new vertex.\n                mergedVertexIndex = previousIndexMap.length;\n                facesIndexed[faceIndex + j] = mergedVertexIndex;\n                vertexHash[key] = mergedVertexIndex;\n                previousIndexMap.push(vertexIndex);\n            }\n        }\n    }\n    const numMergedVertices = previousIndexMap.length;\n    const verticesMerged = new Float32Array(numMergedVertices * 3);\n    for (let i = 0; i < numMergedVertices; i++) {\n        const previousIndex = previousIndexMap[i];\n        verticesMerged[3 * i] = vertices[3 * previousIndex];\n        verticesMerged[3 * i + 1] = vertices[3 * previousIndex + 1];\n        verticesMerged[3 * i + 2] = vertices[3 * previousIndex + 2];\n    }\n    let uvsMerged;\n    if (uvs) {\n        uvsMerged = new Float32Array(numMergedVertices * 2);\n        for (let i = 0; i < numMergedVertices; i++) {\n            const previousIndex = previousIndexMap[i];\n            uvsMerged[2 * i] = uvs[2 * previousIndex];\n            uvsMerged[2 * i + 1] = uvs[2 * previousIndex + 1];\n        }\n    }\n    let vertexNormalsMerged;\n    if (vertexNormals) {\n        vertexNormalsMerged = new Float32Array(numMergedVertices * 3);\n        for (let i = 0; i < numMergedVertices; i++) {\n            const previousIndex = previousIndexMap[i];\n            vertexNormalsMerged[3 * i] = vertexNormals[3 * previousIndex];\n            vertexNormalsMerged[3 * i + 1] = vertexNormals[3 * previousIndex + 1];\n            vertexNormalsMerged[3 * i + 2] = vertexNormals[3 * previousIndex + 2];\n        }\n    }\n    let vertexColorsMerged;\n    if (vertexColors) {\n        vertexColorsMerged = new Float32Array(numMergedVertices * 3);\n        for (let i = 0; i < numMergedVertices; i++) {\n            const previousIndex = previousIndexMap[i];\n            vertexColorsMerged[3 * i] = vertexColors[3 * previousIndex];\n            vertexColorsMerged[3 * i + 1] = vertexColors[3 * previousIndex + 1];\n            vertexColorsMerged[3 * i + 2] = vertexColors[3 * previousIndex + 2];\n        }\n    }\n    return {\n        verticesMerged,\n        uvsMerged,\n        vertexNormalsMerged,\n        vertexColorsMerged,\n        facesIndexed,\n    };\n}\n//# sourceMappingURL=geometry-utils.js.map"],"names":["makeEdgeHash","index1","index2","Math","min","max","makeTriangleFaceHash","index3","parseMSH","data","_MSHMesh","loadMSH","urlOrFile","callback","window","request","XMLHttpRequest","open","responseType","onload","mesh","response","send","import","then","fs","buffer","readFileSync","reader","FileReader","result","readAsArrayBuffer","constructor","this","_offset","arrayBuffer","Uint8Array","dataView","DataView","uint8Array","_parseNextLineAsUTF8","_throwInvalidFormatError","version","type","dataSize","split","map","el","parseFloat","isNaN","Error","doublePrecision","isBinary","isLE","getInt32","numNodes","parseInt","nodesArray","Float64Array","Float32Array","i","index","getFloat64","getFloat32","length","_isFiniteNumber","_nodes","numElements","elementsArray","push","elementIndices","isTetMesh","elementIndex","tagWarning","elementType","elementNumElements","elementNumTags","numElementNodes","_numNodesPerElementType","j","console","warn","nodeIndices","nodeIndex","hash","indices","key","keys","Object","exteriorFacesArray","exteriorNodes","numKeys","a","b","c","d","orientation","_dotProduct","_crossProduct","_vecFromTo","currentIndex","newIndices","Int32Array","_numExteriorNodes","newNodesArray","slice","_exteriorFaceIndices","nodes","newlineIndex","indexOf","text","decoder","decode","subarray","static","number","Infinity","vector1","vector2","from","to","edgeIndices","_edgeIndices","edgeIndicesHash","element","k","undefined","Uint32Array","exteriorEdgeIndices","_exteriorEdgeIndices","faceIndices","numFaces","edgesHash","edges","face","numVertices","calcEdgeIndicesFromNestedIndexedFaces","exteriorFaceIndices","v1","v2","v3","abs","elementVolumes","_elementVolumes","volumes","_tetrahedronVolume","nodalVolumes","_nodalVolumes","numNodeIndices","numExteriorNodes","boundingBox","_boundingBox","vertices","calcBoundingBox","scaleNodesToUnitBoundingBox","target","diff","center","scale","scaleVerticesToUnitBoundingBox","TextDecoder","Promise","resolve"],"mappings":"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"}