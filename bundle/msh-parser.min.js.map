{"version":3,"file":"msh-parser.min.js","sources":["../node_modules/@amandaghassaei/3d-mesh-utils/dist/index-utils.js","../src/msh-parser.ts","../node_modules/@amandaghassaei/3d-mesh-utils/dist/geometry-utils.js"],"sourcesContent":["/**\n * Make hash key for edge.\n * @param index1 - Index of first vertex.\n * @param index2 - Index of second vertex.\n * @returns - Hash key for edge.\n */\nexport function makeEdgeHash(index1, index2) {\n    return `${Math.min(index1, index2)},${Math.max(index1, index2)}`;\n}\n/**\n * Make hash key for triangle face.\n * @param index1 - Index of first vertex.\n * @param index2 - Index of second vertex.\n * @param index3 - Index of third vertex.\n * @returns - Hash key for triangle face.\n */\nexport function makeTriangleFaceHash(index1, index2, index3) {\n    const min = Math.min(index1, index2, index3);\n    const max = Math.max(index1, index2, index3);\n    const sum = index1 + index2 + index3;\n    return `${min},${sum - min - max},${max}`;\n}\nlet tempArray = [];\n/**\n * Make hash key for face with any number of vertices.\n * @param facesIndices - Array of vertex indices.\n * @returns - Hash key for face.\n */\nexport function makeFaceHash(facesIndices) {\n    const length = facesIndices.length;\n    tempArray.length = length;\n    for (let i = 0; i < length; i++) {\n        tempArray[i] = facesIndices[i];\n    }\n    tempArray.sort((a, b) => (a - b));\n    return tempArray.join(',');\n}\n//# sourceMappingURL=index-utils.js.map","import {\n\tcalcBoundingBox,\n\tscaleVerticesToUnitBoundingBox,\n\tcalcEdgesIndicesFromNestedIndexedFaces,\n\tmakeEdgeHash,\n\tmakeTriangleFaceHash,\n} from '@amandaghassaei/3d-mesh-utils';\n\n/**\n * Synchronously parse an already loaded .msh file buffer.\n */\nexport function parseMSH(data: Buffer | ArrayBuffer): MSHMesh {\n\treturn new _MSHMesh(data);\n}\n/**\n * Load and parse .msh asynchronously from the specified url or File object (returns Promise).\n */\nexport function loadMSHAsync(urlOrFile: string | File) {\n\treturn new Promise<MSHMesh>((resolve) => {\n\t\tloadMSH(urlOrFile, (mesh) => {\n\t\t\tresolve(mesh);\n\t\t});\n\t});\n}\n\n/**\n * Load and parse .msh from the specified url or File object.\n */\nexport function loadMSH(urlOrFile: string | File, callback: (mesh: MSHMesh) => void) {\n\tif (typeof urlOrFile === 'string') {\n\t\t// Made this compatible with Node and the browser, maybe there is a better way?\n\t\t/* c8 ignore start */\n\t\tif (typeof window !== 'undefined') {\n\t\t\t// Browser.\n\t\t\t// Load the file with XMLHttpRequest.\n\t\t\tconst request = new XMLHttpRequest();\n\t\t\trequest.open('GET', urlOrFile, true);\n\t\t\trequest.responseType = 'arraybuffer';\n\t\t\trequest.onload = () => {\n\t\t\t\tconst mesh = parseMSH(request.response as ArrayBuffer);\n\t\t\t\t// Call the callback function with the parsed mesh data.\n\t\t\t\tcallback(mesh);\n\t\t\t};\n\t\t\trequest.send();\n\t\t/* c8 ignore stop */\n\t\t} else {\n\t\t\t// Call the callback function with the parsed mesh data.\n\t\t\timport('fs').then((fs) => {\n\t\t\t\tconst buffer = fs.readFileSync(urlOrFile);\n\t\t\t\tcallback(parseMSH(buffer));\n\t\t\t});\n\t\t}\n\t/* c8 ignore start */\n\t} else {\n\t\t// We only ever hit this in the browser.\n\t\t// Load the file with FileReader.\n\t\tconst reader = new FileReader();\n\t\treader.onload = () => {\n\t\t\tconst mesh = parseMSH(reader.result as ArrayBuffer);\n\t\t\t// Call the callback function with the parsed mesh data.\n\t\t\tcallback(mesh);\n\t\t}\n\t\treader.readAsArrayBuffer(urlOrFile);\n\t}\n\t/* c8 ignore stop */\n}\n\n// Export just the type, keep the class private.\nexport type MSHMesh = {\n\treadonly nodes: Float64Array | Float32Array;\n\treadonly nodalVolumes: Float32Array;\n\treadonly elementIndices: number[][];\n\treadonly elementVolumes: Float32Array;\n\treadonly edgesIndices: Uint32Array;\n\treadonly exteriorEdgesIndices: Uint32Array;\n\treadonly exteriorFacesIndices: number[][];\n\treadonly isTetMesh: boolean;\n\treadonly numExteriorNodes: number;\n\treadonly boundingBox: { min: number[], max: number[] };\n\tremoveNonTetElements: () => MSHMesh;\n\tscaleNodesToUnitBoundingBox: () => MSHMesh;\n}\n\n// Based on: https://github.com/PyMesh/PyMesh/blob/main/src/IO/MshLoader.cpp\n// Define the MSHMesh class.\nclass _MSHMesh {\n\t// TextDecoder instance to decode the header as UTF-8.\n\tstatic decoder = new TextDecoder();\n\t// Header offset.\n\tprivate _offset = 0;\n\n\tprivate _nodes: Float64Array | Float32Array;\n\tprivate _elementIndices: number[][];\n\tprivate _edgesIndices?: Uint32Array;\n\tprivate _exteriorEdgesIndices?: Uint32Array;\n\tprivate _elementVolumes?: Float32Array;\n\tprivate _nodalVolumes?: Float32Array;\n\tprivate _boundingBox?: { min: [number, number, number], max: [number, number, number] };\n\tprivate _isTetMesh: boolean;\n\tprivate _exteriorFacesIndices?: number[][];\n\tprivate _numExteriorNodes?: number;\n\n\tconstructor(data: ArrayBuffer | Buffer) {\n\t\tconst arrayBuffer = (data as Buffer).buffer ? new Uint8Array(data as Buffer).buffer : data;\n\t\tconst dataView = new DataView(arrayBuffer);\n\t\t// Create a Uint8Array that references the same underlying memory as the DataView.\n\t\tconst uint8Array = new Uint8Array(dataView.buffer);\n\n\t\t// Parse header.\n\t\t/* c8 ignore next */\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$MeshFormat') _MSHMesh._throwInvalidFormatError();\n\t\tconst [ version, type, dataSize ] = this._parseNextLineAsUTF8(uint8Array).split(' ').map(el => parseFloat(el));\n\t\t/* c8 ignore next */\n\t\tif (isNaN(version) || isNaN(type) || isNaN(dataSize)) _MSHMesh._throwInvalidFormatError();\n\t\t/* c8 ignore next */\n\t\tif (dataSize !== 8 && dataSize !== 4) throw new Error(`msh-parser: This library currently parses .msh files with data size === 8 or 4.  Current file has data size = ${dataSize}. Please submit an issue to the GitHub repo if you encounter this error and attach a sample file.`);\n\t\tconst doublePrecision = dataSize === 8;\n\t\tconst isAscii = type === 0;\n\t\tconst isBinary = type === 1;\n\t\tlet isLE = false;\n\t\tif (isBinary) {\n\t\t\t// Read in extra info from binary header.\n\t\t\t// TODO: how do we know to read as LE here?\n\t\t\tif (dataView.getInt32(this._offset, true) === 1) {\n\t\t\t\t// Read as LE.\n\t\t\t\tisLE = true;\n\t\t\t}\n\t\t\tthis._offset += 4;\n\t\t}\n\t\t/* c8 ignore next */\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$EndMeshFormat') _MSHMesh._throwInvalidFormatError();\n\n\t\t// Read the number of nodes.\n\t\t/* c8 ignore next */\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$Nodes') _MSHMesh._throwInvalidFormatError();\n\t\tconst numNodes = parseInt(this._parseNextLineAsUTF8(uint8Array));\n\t\t// Loop through the nodes.\n\t\tconst nodesArray = doublePrecision ? new Float64Array(3 * numNodes) : new Float32Array(3 * numNodes);\n\t\tif (isBinary) {\n\t\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\t\t// Read the current node.\n\t\t\t\tconst index = dataView.getInt32(this._offset, isLE) - 1; // The .msh node index is 1-indexed.\n\t\t\t\tif (doublePrecision) {\n\t\t\t\t\tnodesArray[3 * index] = dataView.getFloat64(this._offset + 4, isLE);\n\t\t\t\t\tnodesArray[3 * index + 1] = dataView.getFloat64(this._offset + 4 + dataSize, isLE);\n\t\t\t\t\tnodesArray[3 * index + 2] = dataView.getFloat64(this._offset + 4 + 2 * dataSize, isLE);\n\t\t\t\t} else {\n\t\t\t\t\tnodesArray[3 * index] = dataView.getFloat32(this._offset + 4, isLE);\n\t\t\t\t\tnodesArray[3 * index + 1] = dataView.getFloat32(this._offset + 4 + dataSize, isLE);\n\t\t\t\t\tnodesArray[3 * index + 2] = dataView.getFloat32(this._offset + 4 + 2 * dataSize, isLE);\n\t\t\t\t}\n\t\t\t\t// Update the current file's byte offset.\n\t\t\t\tthis._offset += 4 + 3 * dataSize;\n\t\t\t}\n\t\t} else if (isAscii) {\n\t\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\t\t// Read the current node.\n\t\t\t\tconst nodeString = this._parseNextLineAsUTF8(uint8Array);\n\t\t\t\tconst nodeValues = nodeString.trim().split(/\\s+/);\n\t\t\t\tif (nodeValues.length !== 4) _MSHMesh._throwInvalidFormatError();\n\t\t\t\tconst index = parseInt(nodeValues[0]) - 1; // The .msh node index is 1-indexed.\n\t\t\t\tnodesArray[3 * index] = parseFloat(nodeValues[1]);\n\t\t\t\tnodesArray[3 * index + 1] = parseFloat(nodeValues[2]);\n\t\t\t\tnodesArray[3 * index + 2] = parseFloat(nodeValues[3]);\n\t\t\t}\n\t\t/* c8 ignore next 3 */\n\t\t} else {\n\t\t\tthrow new Error('msh-parser: This library currently only parses binary and ascii .msh files.  Please submit an issue to the GitHub repo if you encounter this error and attach a sample file.');\n\t\t}\n\t\t// Check that all nodes are finite.\n\t\tfor (let i = 0; i < nodesArray.length; i++) {\n\t\t\t/* c8 ignore next */\n\t\t\tif (!_MSHMesh._isFiniteNumber(nodesArray[i])) throw new Error('msh-parser: NaN or Inf detected in input file.');\n\t\t}\n\t\t/* c8 ignore next */\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$EndNodes') _MSHMesh._throwInvalidFormatError();\n\t\tthis._nodes = nodesArray;\n\n\t\t/* c8 ignore next */\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$Elements') _MSHMesh._throwInvalidFormatError();\n\n\t\t// Read the number of elementIndices.\n\t\tconst numElements = parseInt(this._parseNextLineAsUTF8(uint8Array));\n\t\tconst elementIndices: number[][] = [];\n\t\tfor (let i = 0; i < numElements; i++) {\n\t\t\telementIndices.push([]);\n\t\t}\n\t\tthis._elementIndices = elementIndices;\n\n\t\t// Check if all elementIndices are tetrahedra.\n\t\tlet isTetMesh = true;\n\t\t// Loop through the elementIndices.\n\t\tlet elementIndex = 0;\n\t\tlet tagWarning = false;\n\t\tif (isBinary) {\n\t\t\twhile (elementIndex < numElements) {\n\t\t\t\t// Parse element header.\n\t\t\t\tconst elementType = dataView.getInt32(this._offset, isLE);\n\t\t\t\tconst elementNumElements = dataView.getInt32(this._offset + 4, isLE);\n\t\t\t\tconst elementNumTags = dataView.getInt32(this._offset + 8, isLE);\n\t\t\t\t/* c8 ignore next */\n\t\t\t\tif (elementType !== 4) isTetMesh = false;\n\t\t\t\tconst numElementNodes = _MSHMesh._numNodesPerElementType(elementType);\n\t\t\t\t// Update the current file's byte offset.\n\t\t\t\tthis._offset += 12;\n\t\t\t\tfor (let i = 0; i < elementNumElements; i++) {\n\t\t\t\t\tconst index = dataView.getInt32(this._offset, isLE) - 1; // The .msh index is 1-indexed.\n\t\t\t\t\t/* c8 ignore next */\n\t\t\t\t\tif (index < 0 || index >= numElements) throw new Error(`msh-parser: Invalid element index ${index} for numElements === ${numElements}.`);\n\t\t\t\t\tthis._offset += 4;\n\t\t\t\t\t/* c8 ignore start */\n\t\t\t\t\tfor (let j = 0; j < elementNumTags; j++) {\n\t\t\t\t\t\t// const tag = dataView.getInt32(this._offset, isLE);\n\t\t\t\t\t\tif (!tagWarning) {\n\t\t\t\t\t\t\ttagWarning = true;\n\t\t\t\t\t\t\tconsole.warn('msh-parser: This library does not currently parse element tags.');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Update the current file's byte offset.\n\t\t\t\t\t\tthis._offset += 4;\n\t\t\t\t\t}\n\t\t\t\t\t/* c8 ignore stop */\n\t\t\t\t\t\n\t\t\t\t\tconst nodeIndices = elementIndices[index];\n\t\t\t\t\tfor (let j = 0; j < numElementNodes; j++) {\n\t\t\t\t\t\tconst nodeIndex = dataView.getInt32(this._offset, isLE) - 1; // The .msh index is 1-indexed.\n\t\t\t\t\t\t/* c8 ignore next */\n\t\t\t\t\t\tif (!_MSHMesh._isFiniteNumber(nodeIndex)) throw new Error('msh-parser: NaN or Inf detected in input file.');\n\t\t\t\t\t\t/* c8 ignore next */\n\t\t\t\t\t\tif (nodeIndex < 0 || nodeIndex >= numNodes) throw new Error(`msh-parser: Invalid node index ${nodeIndex} for numNodes === ${numNodes}.`);\n\t\t\t\t\t\tnodeIndices.push(nodeIndex);\n\t\t\t\t\t\t// Update the current file's byte offset.\n\t\t\t\t\t\tthis._offset += 4;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telementIndex += elementNumElements;\n\t\t\t}\n\t\t} else if (isAscii) {\n\t\t\twhile (elementIndex < numElements) {\n\t\t\t\t// Parse element header.\n\t\t\t\tconst elementString = this._parseNextLineAsUTF8(uint8Array);\n\t\t\t\tconst elementValues = elementString.trim().split(/\\s+/);\n\t\t\t\tconst elementType = parseInt(elementValues[1]);\n\t\t\t\tconst elementNumTags = parseInt(elementValues[2]);\n\t\t\t\t/* c8 ignore next */\n\t\t\t\tif (elementType !== 4) isTetMesh = false;\n\t\t\t\tconst numElementNodes = _MSHMesh._numNodesPerElementType(elementType);\n\t\t\t\tconst elementNumElements = 1;\n\t\t\t\tfor (let i = 0; i < elementNumElements; i++) {\n\t\t\t\t\tconst index = parseInt(elementValues[0]) - 1; // The .msh index is 1-indexed.\n\t\t\t\t\t/* c8 ignore next */\n\t\t\t\t\tif (index < 0 || index >= numElements) throw new Error(`msh-parser: Invalid element index ${index} for numElements === ${numElements}.`);\n\t\t\t\t\t/* c8 ignore start */\n\t\t\t\t\tfor (let j = 0; j < elementNumTags; j++) {\n\t\t\t\t\t\t// const tag = parseFloat(elementValues[3 + j]);\n\t\t\t\t\t\tif (!tagWarning) {\n\t\t\t\t\t\t\ttagWarning = true;\n\t\t\t\t\t\t\tconsole.warn('msh-parser: This library does not currently parse element tags.');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* c8 ignore stop */\n\t\t\t\t\t\n\t\t\t\t\tconst nodeIndices = elementIndices[index];\n\t\t\t\t\tfor (let j = 0; j < numElementNodes; j++) {\n\t\t\t\t\t\tconst nodeIndex = parseInt(elementValues[3 + elementNumTags + j]) - 1; // The .msh index is 1-indexed.\n\t\t\t\t\t\t/* c8 ignore next */\n\t\t\t\t\t\tif (!_MSHMesh._isFiniteNumber(nodeIndex)) throw new Error('msh-parser: NaN or Inf detected in input file.');\n\t\t\t\t\t\t/* c8 ignore next */\n\t\t\t\t\t\tif (nodeIndex < 0 || nodeIndex >= numNodes) throw new Error(`msh-parser: Invalid node index ${nodeIndex} for numNodes === ${numNodes}.`);\n\t\t\t\t\t\tnodeIndices.push(nodeIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telementIndex += elementNumElements;\n\t\t\t}\n\t\t/* c8 ignore next 3 */\n\t\t} else {\n\t\t\tthrow new Error('msh-parser: This library currently only parses binary and ascii .msh files.  Please submit an issue to the GitHub repo if you encounter this error and attach a sample file.');\n\t\t}\n\t\t/* c8 ignore next */\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$EndElements') _MSHMesh._throwInvalidFormatError();\n\n\t\tthis._isTetMesh = isTetMesh;\n\t\tthis._calcExteriorFacesIndices();\n\t}\n\n\tprivate _calcExteriorFacesIndices() {\n\t\tconst { nodes, elementIndices, isTetMesh } = this;\n\t\tconst numNodes = nodes.length / 3;\n\t\tconst numElements = elementIndices.length;\n\t\t// TODO: make this work for non-tet.\n\t\tif (isTetMesh) {\n\t\t\t// For tet meshes, calculate exterior faces.\n\t\t\t// First find all faces that are covered only once, these are on the boundary.\n\t\t\tconst hash: { [key: string]: number[] } = {};\n\t\t\tfor (let i = 0; i < numElements; i++) {\n\t\t\t\tconst indices = elementIndices[i];\n\t\t\t\tfor (let j = 0; j < indices.length; j++) {\n\t\t\t\t\tconst key = makeTriangleFaceHash(indices[j], indices[(j + 1) % 4], indices[(j + 2) % 4]);\n\t\t\t\t\tif (hash[key]) {\n\t\t\t\t\t\thash[key].push(indices[(j + 3) % indices.length]);\n\t\t\t\t\t\t/* c8 ignore next 3 */\n\t\t\t\t\t\tif (hash[key].length > 2) {\n\t\t\t\t\t\t\tthrow new Error(`msh-parser: Hit face ${key} more than twice.`);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\thash[key] = [indices[(j + 3) % 4]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst keys = Object.keys(hash);\n\t\t\tconst exteriorFacesArray: number[][] = [];\n\t\t\tconst exteriorNodes = new Uint8Array(numNodes);\n\t\t\tfor (let i = 0, numKeys = keys.length; i < numKeys; i++) {\n\t\t\t\tconst key = keys[i];\n\t\t\t\tif (hash[key].length !== 1) continue;\n\t\t\t\tconst indices = keys[i].split(',');\n\t\t\t\tconst a = parseInt(indices[0]);\n\t\t\t\tconst b = parseInt(indices[1]);\n\t\t\t\tconst c = parseInt(indices[2]);\n\t\t\t\t// d is the internal node of this tet.\n\t\t\t\tconst d = hash[key][0];\n\t\t\t\t// Use d to calculate the winding order of the triangle.\n\t\t\t\tconst orientation = _MSHMesh._dotProduct(_MSHMesh._crossProduct(\n\t\t\t\t\t_MSHMesh._vecFromTo(a, b, nodes),\n\t\t\t\t\t_MSHMesh._vecFromTo(a, c, nodes),\n\t\t\t\t), _MSHMesh._vecFromTo(a, d, nodes));\n\t\t\t\texteriorFacesArray.push(orientation < 0 ? [a, b, c] : [a, c, b]);\n\t\t\t\t// Mark all nodes as exterior.\n\t\t\t\texteriorNodes[a] = 1;\n\t\t\t\texteriorNodes[b] = 1;\n\t\t\t\texteriorNodes[c] = 1;\n\t\t\t}\n\t\t\t\n\t\t\t// Also reorder the nodes so that the exterior nodes are first.\n\t\t\tlet currentIndex = 0;\n\t\t\tconst newIndices = new Int32Array(numNodes);\n\t\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\t\tif (exteriorNodes[i]) {\n\t\t\t\t\tnewIndices[i] = currentIndex;\n\t\t\t\t\tcurrentIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._numExteriorNodes = currentIndex;\n\t\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\t\tif (!exteriorNodes[i]) {\n\t\t\t\t\tnewIndices[i] = currentIndex;\n\t\t\t\t\tcurrentIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Now that we have a mapping, update nodesArrays, elementsArray, and exteriorFacesArray.\n\t\t\tconst newNodesArray = nodes.slice();\n\t\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\t\tfor (let j = 0; j < 3; j++) {\n\t\t\t\t\tnewNodesArray[3 * newIndices[i] + j] = nodes[3 * i + j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._nodes = newNodesArray;\n\t\t\tfor (let i = 0; i < numElements; i++) {\n\t\t\t\tconst indices = elementIndices[i];\n\t\t\t\tfor (let j = 0; j < indices.length; j++) {\n\t\t\t\t\tindices[j] = newIndices[indices[j]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i = 0; i < exteriorFacesArray.length; i++) {\n\t\t\t\tconst indices = exteriorFacesArray[i];\n\t\t\t\tfor (let j = 0; j < indices.length; j++) {\n\t\t\t\t\tindices[j] = newIndices[indices[j]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._exteriorFacesIndices = exteriorFacesArray;\n\t\t}\n\t}\n\n\tget nodes() {\n\t\treturn this._nodes;\n\t}\n\n\tset nodes(nodes: Float32Array | Float64Array) {\n\t\tthrow new Error(`msh-parser: No nodes setter.`);\n\t}\n\n\tget elementIndices() {\n\t\treturn this._elementIndices;\n\t}\n\n\tset elementIndices(elementIndices: number[][]) {\n\t\tthrow new Error(`msh-parser: No elementIndices setter.`);\n\t}\n\n\tget isTetMesh() {\n\t\treturn this._isTetMesh;\n\t}\n\n\tset isTetMesh(isTetMesh: boolean) {\n\t\tthrow new Error(`msh-parser: No isTetMesh setter.`);\n\t}\n\n\tprivate _parseNextLineAsUTF8(uint8Array: Uint8Array) {\n\t\t// Find the first newline character in the uint8Array.\n\t\tconst newlineIndex = uint8Array.indexOf(10, this._offset); // 10 is the ASCII code for the newline character.\n\t\t// Decode the uint8Array as a UTF-8 encoded string up until the newline character.\n\t\tconst text = _MSHMesh.decoder.decode(uint8Array.subarray(this._offset, newlineIndex));\n\t\t// Update offset.\n\t\tthis._offset = newlineIndex + 1;\n\t\t// Return the decoded string.\n\t\treturn text;\n\t}\n\n\t/* c8 ignore next 3 */\n\tprivate static _throwInvalidFormatError() {\n\t\tthrow new Error('msh-parser: Invalid .msh file format.');\n\t}\n\n\tprivate static _isFiniteNumber(number: number) {\n\t\treturn !isNaN(number) && number !== Infinity && number !== -Infinity;\n\t}\n\n\tprivate static _numNodesPerElementType(elementType: number) {\n\t\tswitch (elementType) {\n\t\t\tcase 2:\n\t\t\t\treturn 3; // Triangle\n\t\t\tcase 3:\n\t\t\t\treturn 4; // Quad\n\t\t\tcase 4:\n\t\t\t\treturn 4; // Tetrahedron\n\t\t\tcase 5:\n\t\t\t\treturn 8; // Hexahedron\n\t\t\t/* c8 ignore next 2 */\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`msh-parser: Element type ${elementType} is not supported yet.`);\n\t\t}\n\t}\n\t\n\t// Calculates the dot product of two vectors.\n\tprivate static _dotProduct(vector1: number[], vector2: number[]) {\n\t\treturn vector1[0] * vector2[0] + vector1[1] * vector2[1] + vector1[2] * vector2[2];\n\t}\n\t\n\t// Calculates the cross product of two vectors.\n\tprivate static _crossProduct(vector1: number[], vector2: number[]) {\n\t\treturn [\n\t\t\tvector1[1] * vector2[2] - vector1[2] * vector2[1],\n\t\t\tvector1[2] * vector2[0] - vector1[0] * vector2[2],\n\t\t\tvector1[0] * vector2[1] - vector1[1] * vector2[0]\n\t\t];\n\t}\n\n\tprivate static _vecFromTo(from: number, to: number, nodesArray: Float32Array | Float64Array) {\n\t\treturn [\n\t\t\tnodesArray[3 * to] - nodesArray[3 * from],\n\t\t\tnodesArray[3 * to + 1] - nodesArray[3 * from + 1],\n\t\t\tnodesArray[3 * to + 2] - nodesArray[3 * from + 2],\n\t\t];\n\t}\n\n\tget edgesIndices() {\n\t\tif (!this._edgesIndices) {\n\t\t\tconst { elementIndices, isTetMesh } = this;\n\t\t\t/* c8 ignore next */\n\t\t\tif (!isTetMesh) throw new Error(`msh-parser: MSHMesh.edgesIndices is not defined for non-tet meshes.`);\n\t\t\t// Calc all edgesIndices in mesh, use hash table to cover each edge only once.\n\t\t\tconst edgesIndicesHash: { [key: string]: boolean } = {};\n\t\t\tconst edgesIndices: number[] = [];\n\t\t\tfor (let i = 0, numElements = elementIndices.length; i < numElements; i++) {\n\t\t\t\tconst element = elementIndices[i];\n\t\t\t\t// For tetrahedra, create an edge between each pair of nodes in element.\n\t\t\t\tconst numNodes = element.length;\n\t\t\t\tfor (let j = 0; j < numNodes; j++) {\n\t\t\t\t\tfor (let k = j + 1; k < numNodes; k++) {\n\t\t\t\t\t\tconst a = element[j];\n\t\t\t\t\t\tconst b = element[k];\n\t\t\t\t\t\tconst key = makeEdgeHash(a, b);\n\t\t\t\t\t\t// Only add each edge once.\n\t\t\t\t\t\tif (edgesIndicesHash[key] === undefined) {\n\t\t\t\t\t\t\tedgesIndicesHash[key] = true;\n\t\t\t\t\t\t\tedgesIndices.push(a, b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._edgesIndices = new Uint32Array(edgesIndices);;\n\t\t}\n\t\treturn this._edgesIndices;\n\t}\n\n\tset edgesIndices(edgesIndices: Uint32Array) {\n\t\tthrow new Error(`msh-parser: No edgesIndices setter.`);\n\t}\n\n\tget exteriorEdgesIndices() {\n\t\tif (!this._exteriorEdgesIndices) {\n\t\t\tconst { isTetMesh, _exteriorFacesIndices } = this;\n\t\t\t/* c8 ignore next */\n\t\t\tif (!isTetMesh) throw new Error(`msh-parser: MSHMesh.exteriorEdgesIndices is not defined for non-tet meshes.`);\n\t\t\tconst edgesIndices = calcEdgesIndicesFromNestedIndexedFaces({ facesIndices: _exteriorFacesIndices! })\n\t\t\tthis._exteriorEdgesIndices = new Uint32Array(edgesIndices);\n\t\t}\n\t\treturn this._exteriorEdgesIndices;\n\t}\n\n\tset exteriorEdgesIndices(exteriorEdgesIndices: Uint32Array) {\n\t\tthrow new Error(`msh-parser: No exteriorEdgesIndices setter.`);\n\t}\n\n\tget exteriorFacesIndices() {\n\t\t/* c8 ignore next */\n\t\tif (!this.isTetMesh || !this._exteriorFacesIndices) throw new Error(`msh-parser: MSHMesh.exteriorFacesIndices is not defined for non-tet meshes.`);\n\t\treturn this._exteriorFacesIndices;\n\t}\n\n\tset exteriorFacesIndices(exteriorFacesIndices: number[][]) {\n\t\tthrow new Error(`msh-parser: No exteriorFacesIndices setter.`);\n\t}\n\n\tprivate static _tetrahedronVolume(indices: number[], nodesArray: Float32Array | Float64Array) {\n\t\tconst [a, b, c, d] = indices;\n\t\t// Calculate the vectors representing the edgesIndices of the tetrahedron.\n\t\tconst v1 = _MSHMesh._vecFromTo(d, a, nodesArray);\n\t\tconst v2 = _MSHMesh._vecFromTo(d, b, nodesArray);\n\t\tconst v3 = _MSHMesh._vecFromTo(d, c, nodesArray);\n\t  \n\t\t// Calculate the volume of the tetrahedron using the formula:\"\"\n\t\t// (1/6) * |v1 . (v2 x v3)|\n\t\t// https://en.wikipedia.org/wiki/Tetrahedron#Volume\n\t\treturn Math.abs(_MSHMesh._dotProduct(v1, _MSHMesh._crossProduct(v2, v3))) / 6;\n\t}\n\n\tget elementVolumes() {\n\t\tif (!this._elementVolumes) {\n\t\t\tconst { elementIndices, nodes, isTetMesh } = this;\n\t\t\t/* c8 ignore next */\n\t\t\tif (!isTetMesh) throw new Error(`msh-parser: MSHMesh.elementVolumes is not defined for non-tet meshes.`);\n\t\t\tconst numElements = elementIndices.length;\n\t\t\tconst volumes = new Float32Array(numElements);\n\t\t\tfor (let i = 0; i < numElements; i++) {\n\t\t\t\tvolumes[i] = _MSHMesh._tetrahedronVolume(elementIndices[i], nodes);\n\t\t\t}\n\t\t\tthis._elementVolumes = volumes;\n\t\t}\n\t\treturn this._elementVolumes;\n\t}\n\n\tset elementVolumes(elementVolumes: Float32Array) {\n\t\tthrow new Error(`msh-parser: No elementVolumes setter.`);\n\t}\n\n\tget nodalVolumes() {\n\t\tif (!this._nodalVolumes) {\n\t\t\tconst { elementIndices, nodes, isTetMesh } = this;\n\t\t\t/* c8 ignore next */\n\t\t\tif (!isTetMesh) throw new Error(`msh-parser: MSHMesh.nodalVolumes is not defined for non-tet meshes.`);\n\t\t\tconst { elementVolumes } = this;\n\t\t\tconst nodalVolumes = new Float32Array(nodes.length / 3);\n\t\t\tfor (let i = 0, numElements = elementIndices.length; i < numElements; i++) {\n\t\t\t\tconst nodeIndices = elementIndices[i];\n\t\t\t\tconst numNodeIndices = nodeIndices.length;\n\t\t\t\tfor (let j = 0; j < numNodeIndices; j++) {\n\t\t\t\t\tconst nodeIndex = nodeIndices[j];\n\t\t\t\t\t// Split element volume evenly across adjacent nodes.\n\t\t\t\t\tnodalVolumes[nodeIndex] += elementVolumes[i] / numNodeIndices;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._nodalVolumes = nodalVolumes;\n\t\t}\n\t\treturn this._nodalVolumes;\n\t}\n\n\tset nodalVolumes(nodalVolumes: Float32Array) {\n\t\tthrow new Error(`msh-parser: No nodalVolumes setter.`);\n\t}\n\n\tget numExteriorNodes() {\n\t\t/* c8 ignore next */\n\t\tif (!this.isTetMesh || !this._numExteriorNodes) throw new Error(`msh-parser: MSHMesh.numExteriorNodes is not defined for non-tet meshes.`);\n\t\treturn this._numExteriorNodes;\n\t}\n\n\tset numExteriorNodes(numExteriorNodes: number) {\n\t\tthrow new Error(`msh-parser: No numExteriorNodes setter.`);\n\t}\n\n\tget boundingBox() {\n\t\tif (!this._boundingBox) {\n\t\t\tthis._boundingBox = calcBoundingBox({\n\t\t\t\tvertices: this.nodes,\n\t\t\t});\n\t\t}\n\t\treturn this._boundingBox;\n\t}\n\n\tset boundingBox(boundingBox: { min: [number, number, number], max: [number, number, number] }) {\n\t\tthrow new Error(`msh-parser: No boundingBox setter.`);\n\t}\n\n\t/**\n\t * Removes non-tetrahedron elements from the mesh.\n\t * @returns this\n\t */\n\tremoveNonTetElements() {\n\t\tconst { elementIndices, isTetMesh } = this;\n\t\tif (isTetMesh) return this;\n\t\tconst tetElementIndices: number[][] = [];\n\t\tfor (let i = elementIndices.length - 1; i >= 0; i--) {\n\t\t\tconst element = elementIndices[i];\n\t\t\tif (element.length === 4) {\n\t\t\t\ttetElementIndices.push(element);\n\t\t\t}\n\t\t}\n\t\tthis._elementIndices = tetElementIndices;\n\t\tthis._isTetMesh = true;\n\t\tdelete this._edgesIndices;\n\t\tdelete this._exteriorEdgesIndices;\n\t\tdelete this._elementVolumes;\n\t\tdelete this._nodalVolumes;\n\t\tdelete this._boundingBox;\n\t\tthis._calcExteriorFacesIndices();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Scales nodes to unit bounding box and centers around origin.\n\t * @returns this\n\t */\n\tscaleNodesToUnitBoundingBox() {\n\t\tscaleVerticesToUnitBoundingBox({\n\t\t\tvertices: this.nodes,\n\t\t\tboundingBox: this.boundingBox,\n\t\t});\n\t\tdelete this._boundingBox;\n\t\tdelete this._nodalVolumes;\n\t\tdelete this._elementVolumes;\n\t\treturn this;\n\t}\n}\n","import { makeEdgeHash } from './index-utils';\n/**\n * Returns the bounding box of the mesh.\n */\nexport function calcBoundingBox(mesh) {\n    const { vertices } = mesh;\n    const numVertices = vertices.length / 3;\n    const min = [Infinity, Infinity, Infinity];\n    const max = [-Infinity, -Infinity, -Infinity];\n    for (let i = 0; i < numVertices; i++) {\n        min[0] = Math.min(min[0], vertices[3 * i]);\n        min[1] = Math.min(min[1], vertices[3 * i + 1]);\n        min[2] = Math.min(min[2], vertices[3 * i + 2]);\n        max[0] = Math.max(max[0], vertices[3 * i]);\n        max[1] = Math.max(max[1], vertices[3 * i + 1]);\n        max[2] = Math.max(max[2], vertices[3 * i + 2]);\n    }\n    return { min, max };\n}\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh contains indexed faces.\n * Vertices are grouped into faces of any size: [[f01, f0b, f0c], [f1a, f1b, f1c, f1d], ...]\n */\nexport function calcEdgesIndicesFromNestedIndexedFaces(mesh) {\n    const { facesIndices } = mesh;\n    // Handle edges on indexed faces.\n    const numFaces = facesIndices.length;\n    // Use hash to calc edges.\n    const edgesHash = {};\n    const edges = [];\n    for (let i = 0; i < numFaces; i++) {\n        const face = facesIndices[i];\n        const numVertices = face.length;\n        for (let j = 0; j < numVertices; j++) {\n            const index1 = face[j];\n            const index2 = face[(j + 1) % numVertices];\n            const key = makeEdgeHash(index1, index2);\n            // Only add each edge once.\n            if (edgesHash[key] === undefined) {\n                edgesHash[key] = true;\n                edges.push(index1, index2);\n            }\n        }\n    }\n    return edges;\n}\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh contains indexed faces.\n * Assumes flat list of triangle faces: [f0a, f0b, f0c, f1a, f1b, f1c, ...]\n */\nexport function calcEdgesIndicesFromIndexedFaces(mesh) {\n    const { facesIndices } = mesh;\n    // Handle edges on indexed faces.\n    const numFaces = facesIndices.length / 3;\n    // Use hash to calc edges.\n    const edgesHash = {};\n    const edgeIndices = [];\n    for (let i = 0; i < numFaces; i++) {\n        for (let j = 0; j < 3; j++) {\n            const index1 = facesIndices[3 * i + j];\n            const index2 = facesIndices[3 * i + (j + 1) % 3];\n            const key = makeEdgeHash(index1, index2);\n            // Only add each edge once.\n            if (edgesHash[key] === undefined) {\n                edgesHash[key] = true;\n                edgeIndices.push(index1, index2);\n            }\n        }\n    }\n    return edgeIndices;\n}\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh vertices are groups in sets of three to a face (triangle mesh).\n */\nexport function calcEdgesIndicesFromNonIndexedFaces(mesh) {\n    const { vertices } = mesh;\n    const numVertices = vertices.length / 3;\n    // Vertices are grouped in sets of three to a face.\n    const numFaces = numVertices / 3;\n    const edges = new Uint32Array(6 * numFaces);\n    for (let i = 0; i < numFaces; i++) {\n        const index = 3 * i;\n        for (let j = 0; j < 3; j++) {\n            const edgeIndex = 6 * i + 2 * j;\n            edges[edgeIndex] = index + j;\n            edges[edgeIndex + 1] = index + (j + 1) % 3;\n        }\n    }\n    return edges;\n}\n/**\n * Scales vertex positions (in place, unless target provided) to unit bounding box and centers around origin.\n * Assumes all vertex positions are used in mesh.\n */\nexport function scaleVerticesToUnitBoundingBox(mesh, target = mesh.vertices) {\n    const { vertices, boundingBox } = mesh;\n    const { min, max } = boundingBox;\n    const diff = [max[0] - min[0], max[1] - min[1], max[2] - min[2]];\n    const center = [(max[0] + min[0]) / 2, (max[1] + min[1]) / 2, (max[2] + min[2]) / 2];\n    const scale = Math.max(diff[0], diff[1], diff[2]);\n    const numNodes = vertices.length / 3;\n    for (let i = 0; i < numNodes; i++) {\n        for (let j = 0; j < 3; j++) {\n            // Uniform scale.\n            target[3 * i + j] = (vertices[3 * i + j] - center[j]) / scale;\n        }\n    }\n}\n/**\n * Merge coincident vertices and index faces.\n */\nexport function mergeVertices(mesh) {\n    const { vertices, uvs, vertexNormals, vertexColors } = mesh;\n    const numFaces = vertices.length / 9;\n    const previousIndexMap = []; // Map from old vertex index to new vertex index.\n    const facesIndexed = new Uint32Array(numFaces * 3);\n    // Use hash to merge vertices.\n    const vertexHash = {};\n    for (let i = 0; i < numFaces; i++) {\n        for (let j = 0; j < 3; j++) {\n            const vertexIndex = 3 * i + j;\n            const positionX = vertices[3 * vertexIndex];\n            const positionY = vertices[3 * vertexIndex + 1];\n            const positionZ = vertices[3 * vertexIndex + 2];\n            let key = `${positionX},${positionY},${positionZ}`;\n            if (uvs) {\n                const uvX = uvs[2 * vertexIndex];\n                const uvY = uvs[2 * vertexIndex + 1];\n                key += `|${uvX},${uvY}`;\n            }\n            if (vertexNormals) {\n                const normalX = vertexNormals[3 * vertexIndex];\n                const normalY = vertexNormals[3 * vertexIndex + 1];\n                const normalZ = vertexNormals[3 * vertexIndex + 2];\n                key += `|${normalX},${normalY},${normalZ}`;\n            }\n            if (vertexColors) {\n                const colorR = vertexColors[3 * vertexIndex];\n                const colorG = vertexColors[3 * vertexIndex + 1];\n                const colorB = vertexColors[3 * vertexIndex + 2];\n                key += `|${colorR},${colorG},${colorB}`;\n            }\n            const faceIndex = 3 * i;\n            let mergedVertexIndex = vertexHash[key];\n            if (mergedVertexIndex !== undefined) {\n                facesIndexed[faceIndex + j] = mergedVertexIndex;\n            }\n            else {\n                // Add new vertex.\n                mergedVertexIndex = previousIndexMap.length;\n                facesIndexed[faceIndex + j] = mergedVertexIndex;\n                vertexHash[key] = mergedVertexIndex;\n                previousIndexMap.push(vertexIndex);\n            }\n        }\n    }\n    const numMergedVertices = previousIndexMap.length;\n    const verticesMerged = new Float32Array(numMergedVertices * 3);\n    for (let i = 0; i < numMergedVertices; i++) {\n        const previousIndex = previousIndexMap[i];\n        verticesMerged[3 * i] = vertices[3 * previousIndex];\n        verticesMerged[3 * i + 1] = vertices[3 * previousIndex + 1];\n        verticesMerged[3 * i + 2] = vertices[3 * previousIndex + 2];\n    }\n    let uvsMerged;\n    if (uvs) {\n        uvsMerged = new Float32Array(numMergedVertices * 2);\n        for (let i = 0; i < numMergedVertices; i++) {\n            const previousIndex = previousIndexMap[i];\n            uvsMerged[2 * i] = uvs[2 * previousIndex];\n            uvsMerged[2 * i + 1] = uvs[2 * previousIndex + 1];\n        }\n    }\n    let vertexNormalsMerged;\n    if (vertexNormals) {\n        vertexNormalsMerged = new Float32Array(numMergedVertices * 3);\n        for (let i = 0; i < numMergedVertices; i++) {\n            const previousIndex = previousIndexMap[i];\n            vertexNormalsMerged[3 * i] = vertexNormals[3 * previousIndex];\n            vertexNormalsMerged[3 * i + 1] = vertexNormals[3 * previousIndex + 1];\n            vertexNormalsMerged[3 * i + 2] = vertexNormals[3 * previousIndex + 2];\n        }\n    }\n    let vertexColorsMerged;\n    if (vertexColors) {\n        vertexColorsMerged = new Float32Array(numMergedVertices * 3);\n        for (let i = 0; i < numMergedVertices; i++) {\n            const previousIndex = previousIndexMap[i];\n            vertexColorsMerged[3 * i] = vertexColors[3 * previousIndex];\n            vertexColorsMerged[3 * i + 1] = vertexColors[3 * previousIndex + 1];\n            vertexColorsMerged[3 * i + 2] = vertexColors[3 * previousIndex + 2];\n        }\n    }\n    return {\n        verticesMerged,\n        uvsMerged,\n        vertexNormalsMerged,\n        vertexColorsMerged,\n        facesIndexed,\n    };\n}\n//# sourceMappingURL=geometry-utils.js.map"],"names":["makeEdgeHash","index1","index2","Math","min","max","makeTriangleFaceHash","index3","parseMSH","data","_MSHMesh","loadMSH","urlOrFile","callback","window","request","XMLHttpRequest","open","responseType","onload","mesh","response","send","import","then","fs","buffer","readFileSync","reader","FileReader","result","readAsArrayBuffer","constructor","this","_offset","arrayBuffer","Uint8Array","dataView","DataView","uint8Array","_parseNextLineAsUTF8","_throwInvalidFormatError","version","type","dataSize","split","map","el","parseFloat","isNaN","Error","doublePrecision","isAscii","isBinary","isLE","getInt32","numNodes","parseInt","nodesArray","Float64Array","Float32Array","i","index","getFloat64","getFloat32","nodeValues","trim","length","_isFiniteNumber","_nodes","numElements","elementIndices","push","_elementIndices","isTetMesh","elementIndex","tagWarning","elementType","elementNumElements","elementNumTags","numElementNodes","_numNodesPerElementType","j","console","warn","nodeIndices","nodeIndex","elementValues","_isTetMesh","_calcExteriorFacesIndices","nodes","hash","indices","key","keys","Object","exteriorFacesArray","exteriorNodes","numKeys","a","b","c","d","orientation","_dotProduct","_crossProduct","_vecFromTo","currentIndex","newIndices","Int32Array","_numExteriorNodes","newNodesArray","slice","_exteriorFacesIndices","newlineIndex","indexOf","text","decoder","decode","subarray","static","number","Infinity","vector1","vector2","from","to","edgesIndices","_edgesIndices","edgesIndicesHash","element","k","undefined","Uint32Array","exteriorEdgesIndices","_exteriorEdgesIndices","facesIndices","numFaces","edgesHash","edges","face","numVertices","calcEdgesIndicesFromNestedIndexedFaces","exteriorFacesIndices","v1","v2","v3","abs","elementVolumes","_elementVolumes","volumes","_tetrahedronVolume","nodalVolumes","_nodalVolumes","numNodeIndices","numExteriorNodes","boundingBox","_boundingBox","vertices","calcBoundingBox","removeNonTetElements","tetElementIndices","scaleNodesToUnitBoundingBox","target","diff","center","scale","scaleVerticesToUnitBoundingBox","TextDecoder","Promise","resolve"],"mappings":"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"}