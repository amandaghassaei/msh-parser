{"version":3,"file":"msh-parser.min.js","sources":["../node_modules/@amandaghassaei/3d-mesh-utils/dist/index-utils.js","../src/msh-parser.ts","../node_modules/@amandaghassaei/3d-mesh-utils/dist/geometry-utils.js"],"sourcesContent":["/**\n * Make hash key for edge.\n * @param index1 - Index of first vertex.\n * @param index2 - Index of second vertex.\n * @returns - Hash key for edge.\n */\nexport function makeEdgeHash(index1, index2) {\n    return `${Math.min(index1, index2)},${Math.max(index1, index2)}`;\n}\n/**\n * Make hash key for triangle face.\n * @param index1 - Index of first vertex.\n * @param index2 - Index of second vertex.\n * @param index3 - Index of third vertex.\n * @returns - Hash key for triangle face.\n */\nexport function makeTriangleFaceHash(index1, index2, index3) {\n    const min = Math.min(index1, index2, index3);\n    const max = Math.max(index1, index2, index3);\n    const sum = index1 + index2 + index3;\n    return `${min},${sum - min - max},${max}`;\n}\nlet tempArray = [];\n/**\n * Make hash key for face with any number of vertices.\n * @param facesIndices - Array of vertex indices.\n * @returns - Hash key for face.\n */\nexport function makeFaceHash(facesIndices) {\n    const length = facesIndices.length;\n    tempArray.length = length;\n    for (let i = 0; i < length; i++) {\n        tempArray[i] = facesIndices[i];\n    }\n    tempArray.sort((a, b) => (a - b));\n    return tempArray.join(',');\n}\n//# sourceMappingURL=index-utils.js.map","import {\n\tcalcBoundingBox,\n\tscaleVerticesToUnitBoundingBox,\n\tcalcEdgesIndicesFromNestedIndexedFaces,\n\tmakeEdgeHash,\n\tmakeTriangleFaceHash,\n} from '@amandaghassaei/3d-mesh-utils';\n\n/**\n * Synchronously parse an already loaded .msh file buffer.\n */\nexport function parseMSH(data: Buffer | ArrayBuffer): MSHMesh {\n\treturn new _MSHMesh(data);\n}\n/**\n * Load and parse .msh asynchronously from the specified url or File object (returns Promise).\n */\nexport function loadMSHAsync(urlOrFile: string | File) {\n\treturn new Promise<MSHMesh>((resolve) => {\n\t\tloadMSH(urlOrFile, (mesh) => {\n\t\t\tresolve(mesh);\n\t\t});\n\t});\n}\n\n/**\n * Load and parse .msh from the specified url or File object.\n */\nexport function loadMSH(urlOrFile: string | File, callback: (mesh: MSHMesh) => void) {\n\tif (typeof urlOrFile === 'string') {\n\t\t// Made this compatible with Node and the browser, maybe there is a better way?\n\t\t/* c8 ignore start */\n\t\tif (typeof window !== 'undefined') {\n\t\t\t// Browser.\n\t\t\t// Load the file with XMLHttpRequest.\n\t\t\tconst request = new XMLHttpRequest();\n\t\t\trequest.open('GET', urlOrFile, true);\n\t\t\trequest.responseType = 'arraybuffer';\n\t\t\trequest.onload = () => {\n\t\t\t\tconst mesh = parseMSH(request.response as ArrayBuffer);\n\t\t\t\t// Call the callback function with the parsed mesh data.\n\t\t\t\tcallback(mesh);\n\t\t\t};\n\t\t\trequest.send();\n\t\t/* c8 ignore stop */\n\t\t} else {\n\t\t\t// Call the callback function with the parsed mesh data.\n\t\t\timport('fs').then((fs) => {\n\t\t\t\tconst buffer = fs.readFileSync(urlOrFile);\n\t\t\t\tcallback(parseMSH(buffer));\n\t\t\t});\n\t\t}\n\t/* c8 ignore start */\n\t} else {\n\t\t// We only ever hit this in the browser.\n\t\t// Load the file with FileReader.\n\t\tconst reader = new FileReader();\n\t\treader.onload = () => {\n\t\t\tconst mesh = parseMSH(reader.result as ArrayBuffer);\n\t\t\t// Call the callback function with the parsed mesh data.\n\t\t\tcallback(mesh);\n\t\t}\n\t\treader.readAsArrayBuffer(urlOrFile);\n\t}\n\t/* c8 ignore stop */\n}\n\n// Export just the type, keep the class private.\nexport type MSHMesh = {\n\treadonly nodes: Float64Array | Float32Array;\n\treadonly nodalVolumes: Float32Array;\n\treadonly elementIndices: number[][];\n\treadonly elementVolumes: Float32Array;\n\treadonly edgesIndices: Uint32Array;\n\treadonly exteriorEdgesIndices: Uint32Array;\n\treadonly exteriorFacesIndices: number[][];\n\treadonly isTetMesh: boolean;\n\treadonly numExteriorNodes: number;\n\treadonly boundingBox: { min: number[], max: number[] };\n\tscaleNodesToUnitBoundingBox: () => MSHMesh;\n}\n\n// Based on: https://github.com/PyMesh/PyMesh/blob/main/src/IO/MshLoader.cpp\n// Define the MSHMesh class.\nclass _MSHMesh {\n\t// TextDecoder instance to decode the header as UTF-8.\n\tstatic decoder = new TextDecoder();\n\t// Header offset.\n\tprivate _offset = 0;\n\n\tprivate _nodes: Float64Array | Float32Array;\n\treadonly elementIndices: number[][];\n\tprivate _edgesIndices?: Uint32Array;\n\tprivate _exteriorEdgesIndices?: Uint32Array;\n\tprivate _elementVolumes?: Float32Array;\n\tprivate _nodalVolumes?: Float32Array;\n\tprivate _boundingBox?: { min: [number, number, number], max: [number, number, number] };\n\treadonly isTetMesh: boolean;\n\tprivate readonly _exteriorFacesIndices?: number[][];\n\tprivate readonly _numExteriorNodes?: number;\n\n\tconstructor(data: ArrayBuffer | Buffer) {\n\t\tconst arrayBuffer = (data as Buffer).buffer ? new Uint8Array(data as Buffer).buffer : data;\n\t\tconst dataView = new DataView(arrayBuffer);\n\t\t// Create a Uint8Array that references the same underlying memory as the DataView.\n\t\tconst uint8Array = new Uint8Array(dataView.buffer);\n\n\t\t// Parse header.\n\t\t/* c8 ignore next */\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$MeshFormat') _MSHMesh._throwInvalidFormatError();\n\t\tconst [ version, type, dataSize ] = this._parseNextLineAsUTF8(uint8Array).split(' ').map(el => parseFloat(el));\n\t\t/* c8 ignore next */\n\t\tif (isNaN(version) || isNaN(type) || isNaN(dataSize)) _MSHMesh._throwInvalidFormatError();\n\t\t/* c8 ignore next */\n\t\tif (dataSize !== 8 && dataSize !== 4) throw new Error(`msh-parser: This library currently parses .msh files with data size === 8 or 4.  Current file has data size = ${dataSize}. Please submit an issue to the GitHub repo if you encounter this error and attach a sample file.`);\n\t\tconst doublePrecision = dataSize === 8;\n\t\tconst isAscii = type === 0;\n\t\tconst isBinary = type === 1;\n\t\tlet isLE = false;\n\t\tif (isBinary) {\n\t\t\t// Read in extra info from binary header.\n\t\t\t// TODO: how do we know to read as LE here?\n\t\t\tif (dataView.getInt32(this._offset, true) === 1) {\n\t\t\t\t// Read as LE.\n\t\t\t\tisLE = true;\n\t\t\t}\n\t\t\tthis._offset += 4;\n\t\t}\n\t\t/* c8 ignore next */\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$EndMeshFormat') _MSHMesh._throwInvalidFormatError();\n\n\t\t// Read the number of nodes.\n\t\t/* c8 ignore next */\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$Nodes') _MSHMesh._throwInvalidFormatError();\n\t\tconst numNodes = parseInt(this._parseNextLineAsUTF8(uint8Array));\n\t\t// Loop through the nodes.\n\t\tconst nodesArray = doublePrecision ? new Float64Array(3 * numNodes) : new Float32Array(3 * numNodes);\n\t\tif (isBinary) {\n\t\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\t\t// Read the current node.\n\t\t\t\tconst index = dataView.getInt32(this._offset, isLE) - 1; // The .msh node index is 1-indexed.\n\t\t\t\tif (doublePrecision) {\n\t\t\t\t\tnodesArray[3 * index] = dataView.getFloat64(this._offset + 4, isLE);\n\t\t\t\t\tnodesArray[3 * index + 1] = dataView.getFloat64(this._offset + 4 + dataSize, isLE);\n\t\t\t\t\tnodesArray[3 * index + 2] = dataView.getFloat64(this._offset + 4 + 2 * dataSize, isLE);\n\t\t\t\t} else {\n\t\t\t\t\tnodesArray[3 * index] = dataView.getFloat32(this._offset + 4, isLE);\n\t\t\t\t\tnodesArray[3 * index + 1] = dataView.getFloat32(this._offset + 4 + dataSize, isLE);\n\t\t\t\t\tnodesArray[3 * index + 2] = dataView.getFloat32(this._offset + 4 + 2 * dataSize, isLE);\n\t\t\t\t}\n\t\t\t\t// Update the current file's byte offset.\n\t\t\t\tthis._offset += 4 + 3 * dataSize;\n\t\t\t}\n\t\t} else if (isAscii) {\n\t\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\t\t// Read the current node.\n\t\t\t\tconst nodeString = this._parseNextLineAsUTF8(uint8Array);\n\t\t\t\tconst nodeValues = nodeString.trim().split(/\\s+/);\n\t\t\t\tif (nodeValues.length !== 4) _MSHMesh._throwInvalidFormatError();\n\t\t\t\tconst index = parseInt(nodeValues[0]); // The .msh node index is 1-indexed.\n\t\t\t\tnodesArray[3 * index] = parseFloat(nodeValues[1]);\n\t\t\t\tnodesArray[3 * index + 1] = parseFloat(nodeValues[2]);\n\t\t\t\tnodesArray[3 * index + 2] = parseFloat(nodeValues[3]);\n\t\t\t}\n\t\t/* c8 ignore next 3 */\n\t\t} else {\n\t\t\tthrow new Error('msh-parser: This library currently only parses binary and ascii .msh files.  Please submit an issue to the GitHub repo if you encounter this error and attach a sample file.');\n\t\t}\n\t\t// Check that all nodes are finite.\n\t\tfor (let i = 0; i < nodesArray.length; i++) {\n\t\t\t/* c8 ignore next */\n\t\t\tif (!_MSHMesh._isFiniteNumber(nodesArray[i])) throw new Error('msh-parser: NaN or Inf detected in input file.');\n\t\t}\n\t\t/* c8 ignore next */\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$EndNodes') _MSHMesh._throwInvalidFormatError();\n\t\tthis._nodes = nodesArray;\n\n\t\t/* c8 ignore next */\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$Elements') _MSHMesh._throwInvalidFormatError();\n\n\t\t// Read the number of elementIndices.\n\t\tconst numElements = parseInt(this._parseNextLineAsUTF8(uint8Array));\n\t\tconst elementsArray: number[][] = [];\n\t\tfor (let i = 0; i < numElements; i++) {\n\t\t\telementsArray.push([]);\n\t\t}\n\t\tthis.elementIndices = elementsArray;\n\n\t\t// Check if all elementIndices are tetrahedra.\n\t\tlet isTetMesh = true;\n\t\t// Loop through the elementIndices.\n\t\tlet elementIndex = 0;\n\t\tlet tagWarning = false;\n\t\tif (isBinary) {\n\t\t\twhile (elementIndex < numElements) {\n\t\t\t\t// Parse element header.\n\t\t\t\tconst elementType = dataView.getInt32(this._offset, isLE);\n\t\t\t\tconst elementNumElements = dataView.getInt32(this._offset + 4, isLE);\n\t\t\t\tconst elementNumTags = dataView.getInt32(this._offset + 8, isLE);\n\t\t\t\t/* c8 ignore next */\n\t\t\t\tif (elementType !== 4) isTetMesh = false;\n\t\t\t\tconst numElementNodes = _MSHMesh._numNodesPerElementType(elementType);\n\t\t\t\t// Update the current file's byte offset.\n\t\t\t\tthis._offset += 12;\n\t\t\t\tfor (let i = 0; i < elementNumElements; i++) {\n\t\t\t\t\tconst index = dataView.getInt32(this._offset, isLE) - 1; // The .msh index is 1-indexed.\n\t\t\t\t\t/* c8 ignore next */\n\t\t\t\t\tif (index < 0 || index >= numElements) throw new Error(`msh-parser: Invalid element index ${index} for numElements === ${numElements}.`);\n\t\t\t\t\tthis._offset += 4;\n\t\t\t\t\t/* c8 ignore start */\n\t\t\t\t\tfor (let j = 0; j < elementNumTags; j++) {\n\t\t\t\t\t\t// const tag = dataView.getInt32(this._offset, isLE);\n\t\t\t\t\t\tif (!tagWarning) {\n\t\t\t\t\t\t\ttagWarning = true;\n\t\t\t\t\t\t\tconsole.warn('msh-parser: This library does not currently parse element tags.');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Update the current file's byte offset.\n\t\t\t\t\t\tthis._offset += 4;\n\t\t\t\t\t}\n\t\t\t\t\t/* c8 ignore stop */\n\t\t\t\t\t\n\t\t\t\t\tconst nodeIndices = elementsArray[index];\n\t\t\t\t\tfor (let j = 0; j < numElementNodes; j++) {\n\t\t\t\t\t\tconst nodeIndex = dataView.getInt32(this._offset, isLE) - 1; // The .msh index is 1-indexed.\n\t\t\t\t\t\t/* c8 ignore next */\n\t\t\t\t\t\tif (!_MSHMesh._isFiniteNumber(nodeIndex)) throw new Error('msh-parser: NaN or Inf detected in input file.');\n\t\t\t\t\t\t/* c8 ignore next */\n\t\t\t\t\t\tif (nodeIndex < 0 || nodeIndex >= numNodes) throw new Error(`msh-parser: Invalid node index ${nodeIndex} for numNodes === ${numNodes}.`);\n\t\t\t\t\t\tnodeIndices.push(nodeIndex);\n\t\t\t\t\t\t// Update the current file's byte offset.\n\t\t\t\t\t\tthis._offset += 4;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telementIndex += elementNumElements;\n\t\t\t}\n\t\t} else if (isAscii) {\n\t\t\twhile (elementIndex < numElements) {\n\t\t\t\t// Parse element header.\n\t\t\t\tconst elementString = this._parseNextLineAsUTF8(uint8Array);\n\t\t\t\tconst elementValues = elementString.trim().split(/\\s+/);\n\t\t\t\tconst elementType = parseInt(elementValues[1]);\n\t\t\t\tconst elementNumTags = parseInt(elementValues[2]);\n\t\t\t\t/* c8 ignore next */\n\t\t\t\tif (elementType !== 4) isTetMesh = false;\n\t\t\t\tconst numElementNodes = _MSHMesh._numNodesPerElementType(elementType);\n\t\t\t\tconst elementNumElements = 1;\n\t\t\t\tfor (let i = 0; i < elementNumElements; i++) {\n\t\t\t\t\tconst index = parseInt(elementValues[0]) - 1; // The .msh index is 1-indexed.\n\t\t\t\t\t/* c8 ignore next */\n\t\t\t\t\tif (index < 0 || index >= numElements) throw new Error(`msh-parser: Invalid element index ${index} for numElements === ${numElements}.`);\n\t\t\t\t\t/* c8 ignore start */\n\t\t\t\t\tfor (let j = 0; j < elementNumTags; j++) {\n\t\t\t\t\t\t// const tag = parseFloat(elementValues[3 + j]);\n\t\t\t\t\t\tif (!tagWarning) {\n\t\t\t\t\t\t\ttagWarning = true;\n\t\t\t\t\t\t\tconsole.warn('msh-parser: This library does not currently parse element tags.');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* c8 ignore stop */\n\t\t\t\t\t\n\t\t\t\t\tconst nodeIndices = elementsArray[index];\n\t\t\t\t\tfor (let j = 0; j < numElementNodes; j++) {\n\t\t\t\t\t\tconst nodeIndex = parseInt(elementValues[3 + elementNumTags + j]) - 1; // The .msh index is 1-indexed.\n\t\t\t\t\t\t/* c8 ignore next */\n\t\t\t\t\t\tif (!_MSHMesh._isFiniteNumber(nodeIndex)) throw new Error('msh-parser: NaN or Inf detected in input file.');\n\t\t\t\t\t\t/* c8 ignore next */\n\t\t\t\t\t\tif (nodeIndex < 0 || nodeIndex >= numNodes) throw new Error(`msh-parser: Invalid node index ${nodeIndex} for numNodes === ${numNodes}.`);\n\t\t\t\t\t\tnodeIndices.push(nodeIndex);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telementIndex += elementNumElements;\n\t\t\t}\n\t\t/* c8 ignore next 3 */\n\t\t} else {\n\t\t\tthrow new Error('msh-parser: This library currently only parses binary and ascii .msh files.  Please submit an issue to the GitHub repo if you encounter this error and attach a sample file.');\n\t\t}\n\t\t/* c8 ignore next */\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$EndElements') _MSHMesh._throwInvalidFormatError();\n\n\t\tthis.isTetMesh = isTetMesh;\n\t\t// TODO: make this work for non-tet.\n\t\tif (isTetMesh) {\n\t\t\t// For tet meshes, calculate exterior faces.\n\t\t\t// First find all faces that are covered only once, these are on the boundary.\n\t\t\tconst hash: { [key: string]: number[] } = {};\n\t\t\tfor (let i = 0; i < numElements; i++) {\n\t\t\t\tconst indices = elementsArray[i];\n\t\t\t\tfor (let j = 0; j < indices.length; j++) {\n\t\t\t\t\tconst key = makeTriangleFaceHash(indices[j], indices[(j + 1) % 4], indices[(j + 2) % 4]);\n\t\t\t\t\tif (hash[key]) {\n\t\t\t\t\t\thash[key].push(indices[(j + 3) % indices.length]);\n\t\t\t\t\t\t/* c8 ignore next 3 */\n\t\t\t\t\t\tif (hash[key].length > 2) {\n\t\t\t\t\t\t\tthrow new Error(`msh-parser: Hit face ${key} more than twice.`);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\thash[key] = [indices[(j + 3) % 4]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst keys = Object.keys(hash);\n\t\t\tconst exteriorFacesArray: number[][] = [];\n\t\t\tconst exteriorNodes = new Uint8Array(numNodes);\n\t\t\tfor (let i = 0, numKeys = keys.length; i < numKeys; i++) {\n\t\t\t\tconst key = keys[i];\n\t\t\t\tif (hash[key].length !== 1) continue;\n\t\t\t\tconst indices = keys[i].split(',');\n\t\t\t\tconst a = parseInt(indices[0]);\n\t\t\t\tconst b = parseInt(indices[1]);\n\t\t\t\tconst c = parseInt(indices[2]);\n\t\t\t\t// d is the internal node of this tet.\n\t\t\t\tconst d = hash[key][0];\n\t\t\t\t// Use d to calculate the winding order of the triangle.\n\t\t\t\tconst orientation = _MSHMesh._dotProduct(_MSHMesh._crossProduct(\n\t\t\t\t\t_MSHMesh._vecFromTo(a, b, nodesArray),\n\t\t\t\t\t_MSHMesh._vecFromTo(a, c, nodesArray),\n\t\t\t\t), _MSHMesh._vecFromTo(a, d, nodesArray));\n\t\t\t\texteriorFacesArray.push(orientation < 0 ? [a, b, c] : [a, c, b]);\n\t\t\t\t// Mark all nodes as exterior.\n\t\t\t\texteriorNodes[a] = 1;\n\t\t\t\texteriorNodes[b] = 1;\n\t\t\t\texteriorNodes[c] = 1;\n\t\t\t}\n\t\t\t\n\t\t\t// Also reorder the nodes so that the exterior nodes are first.\n\t\t\tlet currentIndex = 0;\n\t\t\tconst newIndices = new Int32Array(numNodes);\n\t\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\t\tif (exteriorNodes[i]) {\n\t\t\t\t\tnewIndices[i] = currentIndex;\n\t\t\t\t\tcurrentIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._numExteriorNodes = currentIndex;\n\t\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\t\tif (!exteriorNodes[i]) {\n\t\t\t\t\tnewIndices[i] = currentIndex;\n\t\t\t\t\tcurrentIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Now that we have a mapping, update nodesArrays, elementsArray, and exteriorFacesArray.\n\t\t\tconst newNodesArray = nodesArray.slice();\n\t\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\t\tfor (let j = 0; j < 3; j++) {\n\t\t\t\t\tnewNodesArray[3 * newIndices[i] + j] = nodesArray[3 * i + j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._nodes = newNodesArray;\n\t\t\tfor (let i = 0; i < numElements; i++) {\n\t\t\t\tconst indices = elementsArray[i];\n\t\t\t\tfor (let j = 0; j < indices.length; j++) {\n\t\t\t\t\tindices[j] = newIndices[indices[j]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i = 0; i < exteriorFacesArray.length; i++) {\n\t\t\t\tconst indices = exteriorFacesArray[i];\n\t\t\t\tfor (let j = 0; j < indices.length; j++) {\n\t\t\t\t\tindices[j] = newIndices[indices[j]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._exteriorFacesIndices = exteriorFacesArray;\n\t\t}\n\t}\n\n\tget nodes() {\n\t\treturn this._nodes;\n\t}\n\n\tset nodes(nodes: Float32Array | Float64Array) {\n\t\tthrow new Error(`msh-parser: No nodes setter.`);\n\t}\n\n\tprivate _parseNextLineAsUTF8(uint8Array: Uint8Array) {\n\t\t// Find the first newline character in the uint8Array.\n\t\tconst newlineIndex = uint8Array.indexOf(10, this._offset); // 10 is the ASCII code for the newline character.\n\t\t// Decode the uint8Array as a UTF-8 encoded string up until the newline character.\n\t\tconst text = _MSHMesh.decoder.decode(uint8Array.subarray(this._offset, newlineIndex));\n\t\t// Update offset.\n\t\tthis._offset = newlineIndex + 1;\n\t\t// Return the decoded string.\n\t\treturn text;\n\t}\n\n\t/* c8 ignore next 3 */\n\tprivate static _throwInvalidFormatError() {\n\t\tthrow new Error('msh-parser: Invalid .msh file format.');\n\t}\n\n\tprivate static _isFiniteNumber(number: number) {\n\t\treturn !isNaN(number) && number !== Infinity && number !== -Infinity;\n\t}\n\n\tprivate static _numNodesPerElementType(elementType: number) {\n\t\tswitch (elementType) {\n\t\t\tcase 2:\n\t\t\t\treturn 3; // Triangle\n\t\t\tcase 3:\n\t\t\t\treturn 4; // Quad\n\t\t\tcase 4:\n\t\t\t\treturn 4; // Tetrahedron\n\t\t\tcase 5:\n\t\t\t\treturn 8; // Hexahedron\n\t\t\t/* c8 ignore next 2 */\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`msh-parser: Element type ${elementType} is not supported yet.`);\n\t\t}\n\t}\n\t\n\t// Calculates the dot product of two vectors.\n\tprivate static _dotProduct(vector1: number[], vector2: number[]) {\n\t\treturn vector1[0] * vector2[0] + vector1[1] * vector2[1] + vector1[2] * vector2[2];\n\t}\n\t\n\t// Calculates the cross product of two vectors.\n\tprivate static _crossProduct(vector1: number[], vector2: number[]) {\n\t\treturn [\n\t\t\tvector1[1] * vector2[2] - vector1[2] * vector2[1],\n\t\t\tvector1[2] * vector2[0] - vector1[0] * vector2[2],\n\t\t\tvector1[0] * vector2[1] - vector1[1] * vector2[0]\n\t\t];\n\t}\n\n\tprivate static _vecFromTo(from: number, to: number, nodesArray: Float32Array | Float64Array) {\n\t\treturn [\n\t\t\tnodesArray[3 * to] - nodesArray[3 * from],\n\t\t\tnodesArray[3 * to + 1] - nodesArray[3 * from + 1],\n\t\t\tnodesArray[3 * to + 2] - nodesArray[3 * from + 2],\n\t\t];\n\t}\n\n\tget edgesIndices() {\n\t\tif (!this._edgesIndices) {\n\t\t\tconst { elementIndices, isTetMesh } = this;\n\t\t\t/* c8 ignore next */\n\t\t\tif (!isTetMesh) throw new Error(`msh-parser: MSHMesh.edgesIndices is not defined for non-tet meshes.`);\n\t\t\t// Calc all edgesIndices in mesh, use hash table to cover each edge only once.\n\t\t\tconst edgesIndicesHash: { [key: string]: boolean } = {};\n\t\t\tconst edgesIndices: number[] = [];\n\t\t\tfor (let i = 0, numElements = elementIndices.length; i < numElements; i++) {\n\t\t\t\tconst element = elementIndices[i];\n\t\t\t\t// For tetrahedra, create an edge between each pair of nodes in element.\n\t\t\t\tconst numNodes = element.length;\n\t\t\t\tfor (let j = 0; j < numNodes; j++) {\n\t\t\t\t\tfor (let k = j + 1; k < numNodes; k++) {\n\t\t\t\t\t\tconst a = element[j];\n\t\t\t\t\t\tconst b = element[k];\n\t\t\t\t\t\tconst key = makeEdgeHash(a, b);\n\t\t\t\t\t\t// Only add each edge once.\n\t\t\t\t\t\tif (edgesIndicesHash[key] === undefined) {\n\t\t\t\t\t\t\tedgesIndicesHash[key] = true;\n\t\t\t\t\t\t\tedgesIndices.push(a, b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._edgesIndices = new Uint32Array(edgesIndices);;\n\t\t}\n\t\treturn this._edgesIndices;\n\t}\n\n\tset edgesIndices(edgesIndices: Uint32Array) {\n\t\tthrow new Error(`msh-parser: No edgesIndices setter.`);\n\t}\n\n\tget exteriorEdgesIndices() {\n\t\tif (!this._exteriorEdgesIndices) {\n\t\t\tconst { isTetMesh, _exteriorFacesIndices } = this;\n\t\t\t/* c8 ignore next */\n\t\t\tif (!isTetMesh) throw new Error(`msh-parser: MSHMesh.exteriorEdgesIndices is not defined for non-tet meshes.`);\n\t\t\tconst edgesIndices = calcEdgesIndicesFromNestedIndexedFaces({ facesIndices: _exteriorFacesIndices! })\n\t\t\tthis._exteriorEdgesIndices = new Uint32Array(edgesIndices);\n\t\t}\n\t\treturn this._exteriorEdgesIndices;\n\t}\n\n\tset exteriorEdgesIndices(exteriorEdgesIndices: Uint32Array) {\n\t\tthrow new Error(`msh-parser: No exteriorEdgesIndices setter.`);\n\t}\n\n\tget exteriorFacesIndices() {\n\t\t/* c8 ignore next */\n\t\tif (!this.isTetMesh || !this._exteriorFacesIndices) throw new Error(`msh-parser: MSHMesh.exteriorFacesIndices is not defined for non-tet meshes.`);\n\t\treturn this._exteriorFacesIndices;\n\t}\n\n\tset exteriorFacesIndices(exteriorFacesIndices: number[][]) {\n\t\tthrow new Error(`msh-parser: No exteriorFacesIndices setter.`);\n\t}\n\n\tprivate static _tetrahedronVolume(indices: number[], nodesArray: Float32Array | Float64Array) {\n\t\tconst [a, b, c, d] = indices;\n\t\t// Calculate the vectors representing the edgesIndices of the tetrahedron.\n\t\tconst v1 = _MSHMesh._vecFromTo(d, a, nodesArray);\n\t\tconst v2 = _MSHMesh._vecFromTo(d, b, nodesArray);\n\t\tconst v3 = _MSHMesh._vecFromTo(d, c, nodesArray);\n\t  \n\t\t// Calculate the volume of the tetrahedron using the formula:\"\"\n\t\t// (1/6) * |v1 . (v2 x v3)|\n\t\t// https://en.wikipedia.org/wiki/Tetrahedron#Volume\n\t\treturn Math.abs(_MSHMesh._dotProduct(v1, _MSHMesh._crossProduct(v2, v3))) / 6;\n\t}\n\n\tget elementVolumes() {\n\t\tif (!this._elementVolumes) {\n\t\t\tconst { elementIndices, nodes, isTetMesh } = this;\n\t\t\t/* c8 ignore next */\n\t\t\tif (!isTetMesh) throw new Error(`msh-parser: MSHMesh.elementVolumes is not defined for non-tet meshes.`);\n\t\t\tconst numElements = elementIndices.length;\n\t\t\tconst volumes = new Float32Array(numElements);\n\t\t\tfor (let i = 0; i < numElements; i++) {\n\t\t\t\tvolumes[i] = _MSHMesh._tetrahedronVolume(elementIndices[i], nodes);\n\t\t\t}\n\t\t\tthis._elementVolumes = volumes;\n\t\t}\n\t\treturn this._elementVolumes;\n\t}\n\n\tset elementVolumes(elementVolumes: Float32Array) {\n\t\tthrow new Error(`msh-parser: No elementVolumes setter.`);\n\t}\n\n\tget nodalVolumes() {\n\t\tif (!this._nodalVolumes) {\n\t\t\tconst { elementIndices, nodes, isTetMesh } = this;\n\t\t\t/* c8 ignore next */\n\t\t\tif (!isTetMesh) throw new Error(`msh-parser: MSHMesh.nodalVolumes is not defined for non-tet meshes.`);\n\t\t\tconst { elementVolumes } = this;\n\t\t\tconst nodalVolumes = new Float32Array(nodes.length / 3);\n\t\t\tfor (let i = 0, numElements = elementIndices.length; i < numElements; i++) {\n\t\t\t\tconst nodeIndices = elementIndices[i];\n\t\t\t\tconst numNodeIndices = nodeIndices.length;\n\t\t\t\tfor (let j = 0; j < numNodeIndices; j++) {\n\t\t\t\t\tconst nodeIndex = nodeIndices[j];\n\t\t\t\t\t// Split element volume evenly across adjacent nodes.\n\t\t\t\t\tnodalVolumes[nodeIndex] += elementVolumes[i] / numNodeIndices;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._nodalVolumes = nodalVolumes;\n\t\t}\n\t\treturn this._nodalVolumes;\n\t}\n\n\tset nodalVolumes(nodalVolumes: Float32Array) {\n\t\tthrow new Error(`msh-parser: No nodalVolumes setter.`);\n\t}\n\n\tget numExteriorNodes() {\n\t\t/* c8 ignore next */\n\t\tif (!this.isTetMesh || !this._numExteriorNodes) throw new Error(`msh-parser: MSHMesh.numExteriorNodes is not defined for non-tet meshes.`);\n\t\treturn this._numExteriorNodes;\n\t}\n\n\tset numExteriorNodes(numExteriorNodes: number) {\n\t\tthrow new Error(`msh-parser: No numExteriorNodes setter.`);\n\t}\n\n\tget boundingBox() {\n\t\tif (!this._boundingBox) {\n\t\t\tthis._boundingBox = calcBoundingBox({\n\t\t\t\tvertices: this.nodes,\n\t\t\t});\n\t\t}\n\t\treturn this._boundingBox;\n\t}\n\n\tset boundingBox(boundingBox: { min: [number, number, number], max: [number, number, number] }) {\n\t\tthrow new Error(`msh-parser: No boundingBox setter.`);\n\t}\n\n\t/**\n\t * Scales nodes to unit bounding box and centers around origin.\n\t */\n\tscaleNodesToUnitBoundingBox() {\n\t\tscaleVerticesToUnitBoundingBox({\n\t\t\tvertices: this.nodes,\n\t\t\tboundingBox: this.boundingBox,\n\t\t});\n\t\tdelete this._boundingBox;\n\t\tdelete this._nodalVolumes;\n\t\tdelete this._elementVolumes;\n\t\treturn this;\n\t}\n}\n","import { makeEdgeHash } from './index-utils';\n/**\n * Returns the bounding box of the mesh.\n */\nexport function calcBoundingBox(mesh) {\n    const { vertices } = mesh;\n    const numVertices = vertices.length / 3;\n    const min = [Infinity, Infinity, Infinity];\n    const max = [-Infinity, -Infinity, -Infinity];\n    for (let i = 0; i < numVertices; i++) {\n        min[0] = Math.min(min[0], vertices[3 * i]);\n        min[1] = Math.min(min[1], vertices[3 * i + 1]);\n        min[2] = Math.min(min[2], vertices[3 * i + 2]);\n        max[0] = Math.max(max[0], vertices[3 * i]);\n        max[1] = Math.max(max[1], vertices[3 * i + 1]);\n        max[2] = Math.max(max[2], vertices[3 * i + 2]);\n    }\n    return { min, max };\n}\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh contains indexed faces.\n * Vertices are grouped into faces of any size: [[f01, f0b, f0c], [f1a, f1b, f1c, f1d], ...]\n */\nexport function calcEdgesIndicesFromNestedIndexedFaces(mesh) {\n    const { facesIndices } = mesh;\n    // Handle edges on indexed faces.\n    const numFaces = facesIndices.length;\n    // Use hash to calc edges.\n    const edgesHash = {};\n    const edges = [];\n    for (let i = 0; i < numFaces; i++) {\n        const face = facesIndices[i];\n        const numVertices = face.length;\n        for (let j = 0; j < numVertices; j++) {\n            const index1 = face[j];\n            const index2 = face[(j + 1) % numVertices];\n            const key = makeEdgeHash(index1, index2);\n            // Only add each edge once.\n            if (edgesHash[key] === undefined) {\n                edgesHash[key] = true;\n                edges.push(index1, index2);\n            }\n        }\n    }\n    return edges;\n}\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh contains indexed faces.\n * Assumes flat list of triangle faces: [f0a, f0b, f0c, f1a, f1b, f1c, ...]\n */\nexport function calcEdgesIndicesFromIndexedFaces(mesh) {\n    const { facesIndices } = mesh;\n    // Handle edges on indexed faces.\n    const numFaces = facesIndices.length / 3;\n    // Use hash to calc edges.\n    const edgesHash = {};\n    const edgeIndices = [];\n    for (let i = 0; i < numFaces; i++) {\n        for (let j = 0; j < 3; j++) {\n            const index1 = facesIndices[3 * i + j];\n            const index2 = facesIndices[3 * i + (j + 1) % 3];\n            const key = makeEdgeHash(index1, index2);\n            // Only add each edge once.\n            if (edgesHash[key] === undefined) {\n                edgesHash[key] = true;\n                edgeIndices.push(index1, index2);\n            }\n        }\n    }\n    return edgeIndices;\n}\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh vertices are groups in sets of three to a face (triangle mesh).\n */\nexport function calcEdgesIndicesFromNonIndexedFaces(mesh) {\n    const { vertices } = mesh;\n    const numVertices = vertices.length / 3;\n    // Vertices are grouped in sets of three to a face.\n    const numFaces = numVertices / 3;\n    const edges = new Uint32Array(6 * numFaces);\n    for (let i = 0; i < numFaces; i++) {\n        const index = 3 * i;\n        for (let j = 0; j < 3; j++) {\n            const edgeIndex = 6 * i + 2 * j;\n            edges[edgeIndex] = index + j;\n            edges[edgeIndex + 1] = index + (j + 1) % 3;\n        }\n    }\n    return edges;\n}\n/**\n * Scales vertex positions (in place, unless target provided) to unit bounding box and centers around origin.\n * Assumes all vertex positions are used in mesh.\n */\nexport function scaleVerticesToUnitBoundingBox(mesh, target = mesh.vertices) {\n    const { vertices, boundingBox } = mesh;\n    const { min, max } = boundingBox;\n    const diff = [max[0] - min[0], max[1] - min[1], max[2] - min[2]];\n    const center = [(max[0] + min[0]) / 2, (max[1] + min[1]) / 2, (max[2] + min[2]) / 2];\n    const scale = Math.max(diff[0], diff[1], diff[2]);\n    const numNodes = vertices.length / 3;\n    for (let i = 0; i < numNodes; i++) {\n        for (let j = 0; j < 3; j++) {\n            // Uniform scale.\n            target[3 * i + j] = (vertices[3 * i + j] - center[j]) / scale;\n        }\n    }\n}\n/**\n * Merge coincident vertices and index faces.\n */\nexport function mergeVertices(mesh) {\n    const { vertices, uvs, vertexNormals, vertexColors } = mesh;\n    const numFaces = vertices.length / 9;\n    const previousIndexMap = []; // Map from old vertex index to new vertex index.\n    const facesIndexed = new Uint32Array(numFaces * 3);\n    // Use hash to merge vertices.\n    const vertexHash = {};\n    for (let i = 0; i < numFaces; i++) {\n        for (let j = 0; j < 3; j++) {\n            const vertexIndex = 3 * i + j;\n            const positionX = vertices[3 * vertexIndex];\n            const positionY = vertices[3 * vertexIndex + 1];\n            const positionZ = vertices[3 * vertexIndex + 2];\n            let key = `${positionX},${positionY},${positionZ}`;\n            if (uvs) {\n                const uvX = uvs[2 * vertexIndex];\n                const uvY = uvs[2 * vertexIndex + 1];\n                key += `|${uvX},${uvY}`;\n            }\n            if (vertexNormals) {\n                const normalX = vertexNormals[3 * vertexIndex];\n                const normalY = vertexNormals[3 * vertexIndex + 1];\n                const normalZ = vertexNormals[3 * vertexIndex + 2];\n                key += `|${normalX},${normalY},${normalZ}`;\n            }\n            if (vertexColors) {\n                const colorR = vertexColors[3 * vertexIndex];\n                const colorG = vertexColors[3 * vertexIndex + 1];\n                const colorB = vertexColors[3 * vertexIndex + 2];\n                key += `|${colorR},${colorG},${colorB}`;\n            }\n            const faceIndex = 3 * i;\n            let mergedVertexIndex = vertexHash[key];\n            if (mergedVertexIndex !== undefined) {\n                facesIndexed[faceIndex + j] = mergedVertexIndex;\n            }\n            else {\n                // Add new vertex.\n                mergedVertexIndex = previousIndexMap.length;\n                facesIndexed[faceIndex + j] = mergedVertexIndex;\n                vertexHash[key] = mergedVertexIndex;\n                previousIndexMap.push(vertexIndex);\n            }\n        }\n    }\n    const numMergedVertices = previousIndexMap.length;\n    const verticesMerged = new Float32Array(numMergedVertices * 3);\n    for (let i = 0; i < numMergedVertices; i++) {\n        const previousIndex = previousIndexMap[i];\n        verticesMerged[3 * i] = vertices[3 * previousIndex];\n        verticesMerged[3 * i + 1] = vertices[3 * previousIndex + 1];\n        verticesMerged[3 * i + 2] = vertices[3 * previousIndex + 2];\n    }\n    let uvsMerged;\n    if (uvs) {\n        uvsMerged = new Float32Array(numMergedVertices * 2);\n        for (let i = 0; i < numMergedVertices; i++) {\n            const previousIndex = previousIndexMap[i];\n            uvsMerged[2 * i] = uvs[2 * previousIndex];\n            uvsMerged[2 * i + 1] = uvs[2 * previousIndex + 1];\n        }\n    }\n    let vertexNormalsMerged;\n    if (vertexNormals) {\n        vertexNormalsMerged = new Float32Array(numMergedVertices * 3);\n        for (let i = 0; i < numMergedVertices; i++) {\n            const previousIndex = previousIndexMap[i];\n            vertexNormalsMerged[3 * i] = vertexNormals[3 * previousIndex];\n            vertexNormalsMerged[3 * i + 1] = vertexNormals[3 * previousIndex + 1];\n            vertexNormalsMerged[3 * i + 2] = vertexNormals[3 * previousIndex + 2];\n        }\n    }\n    let vertexColorsMerged;\n    if (vertexColors) {\n        vertexColorsMerged = new Float32Array(numMergedVertices * 3);\n        for (let i = 0; i < numMergedVertices; i++) {\n            const previousIndex = previousIndexMap[i];\n            vertexColorsMerged[3 * i] = vertexColors[3 * previousIndex];\n            vertexColorsMerged[3 * i + 1] = vertexColors[3 * previousIndex + 1];\n            vertexColorsMerged[3 * i + 2] = vertexColors[3 * previousIndex + 2];\n        }\n    }\n    return {\n        verticesMerged,\n        uvsMerged,\n        vertexNormalsMerged,\n        vertexColorsMerged,\n        facesIndexed,\n    };\n}\n//# sourceMappingURL=geometry-utils.js.map"],"names":["makeEdgeHash","index1","index2","Math","min","max","makeTriangleFaceHash","index3","parseMSH","data","_MSHMesh","loadMSH","urlOrFile","callback","window","request","XMLHttpRequest","open","responseType","onload","mesh","response","send","import","then","fs","buffer","readFileSync","reader","FileReader","result","readAsArrayBuffer","constructor","this","_offset","arrayBuffer","Uint8Array","dataView","DataView","uint8Array","_parseNextLineAsUTF8","_throwInvalidFormatError","version","type","dataSize","split","map","el","parseFloat","isNaN","Error","doublePrecision","isAscii","isBinary","isLE","getInt32","numNodes","parseInt","nodesArray","Float64Array","Float32Array","i","index","getFloat64","getFloat32","nodeValues","trim","length","_isFiniteNumber","_nodes","numElements","elementsArray","push","elementIndices","isTetMesh","elementIndex","tagWarning","elementType","elementNumElements","elementNumTags","numElementNodes","_numNodesPerElementType","j","console","warn","nodeIndices","nodeIndex","elementValues","hash","indices","key","keys","Object","exteriorFacesArray","exteriorNodes","numKeys","a","b","c","d","orientation","_dotProduct","_crossProduct","_vecFromTo","currentIndex","newIndices","Int32Array","_numExteriorNodes","newNodesArray","slice","_exteriorFacesIndices","nodes","newlineIndex","indexOf","text","decoder","decode","subarray","static","number","Infinity","vector1","vector2","from","to","edgesIndices","_edgesIndices","edgesIndicesHash","element","k","undefined","Uint32Array","exteriorEdgesIndices","_exteriorEdgesIndices","facesIndices","numFaces","edgesHash","edges","face","numVertices","calcEdgesIndicesFromNestedIndexedFaces","exteriorFacesIndices","v1","v2","v3","abs","elementVolumes","_elementVolumes","volumes","_tetrahedronVolume","nodalVolumes","_nodalVolumes","numNodeIndices","numExteriorNodes","boundingBox","_boundingBox","vertices","calcBoundingBox","scaleNodesToUnitBoundingBox","target","diff","center","scale","scaleVerticesToUnitBoundingBox","TextDecoder","Promise","resolve"],"mappings":"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"}