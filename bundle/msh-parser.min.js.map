{"version":3,"file":"msh-parser.min.js","sources":["../src/msh-parser.ts","../node_modules/@amandaghassaei/3d-mesh-utils/dist/3d-mesh-utils.js"],"sourcesContent":["import {\n\tcalcBoundingBox,\n\tscaleVerticesToUnitBoundingBox,\n\tcalcEdgesFromNestedIndexedFaces,\n} from '@amandaghassaei/3d-mesh-utils';\n\n/**\n * Synchronously parse an already loaded .msh file buffer.\n */\nexport function parseMsh(data: Buffer | ArrayBuffer): MSHMesh {\n\treturn new _MSHMesh(data);\n}\n/**\n * Load and parse .msh asynchronously from the specified url or File object (returns Promise).\n */\nexport function loadMshAsync(urlOrFile: string | File) {\n\treturn new Promise<MSHMesh>((resolve) => {\n\t\tloadMsh(urlOrFile, (mesh) => {\n\t\t\tresolve(mesh);\n\t\t});\n\t});\n}\n\n/**\n * Load and parse .msh from the specified url or File object.\n */\nexport function loadMsh(urlOrFile: string | File, callback: (mesh: MSHMesh) => void) {\n\tif (typeof urlOrFile === 'string') {\n\t\t// Made this compatible with Node and the browser, maybe there is a better way?\n\t\t/* c8 ignore start */\n\t\tif (typeof window !== 'undefined') {\n\t\t\t\n\t\t\t// Load the file with XMLHttpRequest.\n\t\t\tconst request = new XMLHttpRequest();\n\t\t\trequest.open('GET', urlOrFile, true);\n\t\t\trequest.responseType = 'arraybuffer';\n\t\t\trequest.onload = () => {\n\t\t\t\tconst mesh = parseMsh(request.response as ArrayBuffer);\n\t\t\t\t// Call the callback function with the parsed mesh data.\n\t\t\t\tcallback(mesh);\n\t\t\t};\n\t\t\trequest.send();\n\t\t/* c8 ignore stop */\n\t\t} else {\n\t\t\t// Call the callback function with the parsed mesh data.\n\t\t\timport('fs').then((fs) => {\n\t\t\t\tconst buffer = fs.readFileSync(urlOrFile);\n\t\t\t\tcallback(parseMsh(buffer));\n\t\t\t});\n\t\t}\n\t/* c8 ignore start */\n\t} else {\n\t\t// We only ever hit this in the browser.\n\t\t// Load the file with FileReader.\n\t\tconst reader = new FileReader();\n\t\treader.onload = () => {\n\t\t\tconst mesh = parseMsh(reader.result as ArrayBuffer);\n\t\t\t// Call the callback function with the parsed mesh data.\n\t\t\tcallback(mesh);\n\t\t}\n\t\treader.readAsArrayBuffer(urlOrFile);\n\t}\n\t/* c8 ignore stop */\n}\n\n// Export just the type, keep the class private.\nexport type MSHMesh = {\n\treadonly nodes: Float64Array | Float32Array;\n\treadonly elements: number[][];\n\treadonly edges: Uint32Array;\n\treadonly exteriorEdges: Uint32Array;\n\treadonly exteriorFaces: number[][];\n\treadonly elementVolumes: Float32Array;\n\treadonly nodalVolumes: Float32Array;\n\treadonly isTetMesh: boolean;\n\treadonly numExteriorNodes: number;\n\treadonly boundingBox: { min: number[], max: number[] };\n\tscaleNodesToUnitBoundingBox: () => MSHMesh;\n}\n\n// Based on: https://github.com/PyMesh/PyMesh/blob/main/src/IO/MshLoader.cpp\n// Define the MSHMesh class.\nclass _MSHMesh {\n\t// TextDecoder instance to decode the header as UTF-8.\n\tstatic decoder = new TextDecoder();\n\t// Header offset.\n\tprivate _offset = 0;\n\n\tprivate _nodes: Float64Array | Float32Array;\n\treadonly elements: number[][];\n\tprivate _edges?: Uint32Array;\n\tprivate _exteriorEdges?: Uint32Array;\n\tprivate _elementVolumes?: Float32Array;\n\tprivate _nodalVolumes?: Float32Array;\n\tprivate _boundingBox?: { min: [number, number, number], max: [number, number, number] };\n\treadonly isTetMesh: boolean;\n\tprivate readonly _exteriorFaces?: number[][];\n\tprivate readonly _numExteriorNodes?: number;\n\n\tconstructor(data: ArrayBuffer | Buffer) {\n\t\tconst arrayBuffer = (data as Buffer).buffer ? new Uint8Array(data as Buffer).buffer : data;\n\t\tconst dataView = new DataView(arrayBuffer);\n\t\t// Create a Uint8Array that references the same underlying memory as the DataView.\n\t\tconst uint8Array = new Uint8Array(dataView.buffer);\n\n\t\t// Parse header.\n\t\t/* c8 ignore next */\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$MeshFormat') _MSHMesh._throwInvalidFormatError();\n\t\tconst [ version, type, dataSize ] = this._parseNextLineAsUTF8(uint8Array).split(' ').map(el => parseFloat(el));\n\t\t/* c8 ignore next */\n\t\tif (isNaN(version) || isNaN(type) || isNaN(dataSize)) _MSHMesh._throwInvalidFormatError();\n\t\t/* c8 ignore next */\n\t\tif (dataSize !== 8 && dataSize !== 4) throw new Error(`msh-parser: This library currently parses .msh files with data size === 8 or 4.  Current file has data size = ${dataSize}. Please submit an issue to the GitHub repo if you encounter this error and attach a sample file.`);\n\t\tconst doublePrecision = dataSize === 8;\n\t\tconst isBinary = type === 1;\n\t\tlet isLE = false;\n\t\tif (isBinary) {\n\t\t\t// Read in extra info from binary header.\n\t\t\t// TODO: how do we know to read as LE here?\n\t\t\tif (dataView.getInt32(this._offset, true) === 1) {\n\t\t\t\t// Read as LE.\n\t\t\t\tisLE = true;\n\t\t\t}\n\t\t\tthis._offset += 4;\n\t\t}\n\t\t/* c8 ignore next */\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$EndMeshFormat') _MSHMesh._throwInvalidFormatError();\n\n\t\t// Read the number of nodes.\n\t\t/* c8 ignore next */\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$Nodes') _MSHMesh._throwInvalidFormatError();\n\t\tconst numNodes = parseInt(this._parseNextLineAsUTF8(uint8Array));\n\t\t// Loop through the nodes.\n\t\tconst nodesArray = doublePrecision ? new Float64Array(3 * numNodes) : new Float32Array(3 * numNodes);\n\t\tif (isBinary) {\n\t\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\t\t// Read the current node.\n\t\t\t\tconst index = dataView.getInt32(this._offset, isLE) - 1; // The .msh node index is 1-indexed.\n\t\t\t\tif (doublePrecision) {\n\t\t\t\t\tnodesArray[3 * index] = dataView.getFloat64(this._offset + 4, isLE);\n\t\t\t\t\tnodesArray[3 * index + 1] = dataView.getFloat64(this._offset + 4 + dataSize, isLE);\n\t\t\t\t\tnodesArray[3 * index + 2] = dataView.getFloat64(this._offset + 4 + 2 * dataSize, isLE);\n\t\t\t\t} else {\n\t\t\t\t\tnodesArray[3 * index] = dataView.getFloat32(this._offset + 4, isLE);\n\t\t\t\t\tnodesArray[3 * index + 1] = dataView.getFloat32(this._offset + 4 + dataSize, isLE);\n\t\t\t\t\tnodesArray[3 * index + 2] = dataView.getFloat32(this._offset + 4 + 2 * dataSize, isLE);\n\t\t\t\t}\n\t\t\t\t// Update the current file's byte offset.\n\t\t\t\tthis._offset += 4 + 3 * dataSize;\n\t\t\t}\n\t\t/* c8 ignore next 3 */\n\t\t} else {\n\t\t\tthrow new Error('msh-parser: This library does not currently parse non-binary .msh files.  Please submit an issue to the GitHub repo if you encounter this error and attach a sample file.');\n\t\t}\n\t\t// Check that all nodes are finite.\n\t\tfor (let i = 0; i < nodesArray.length; i++) {\n\t\t\t/* c8 ignore next */\n\t\t\tif (!_MSHMesh._isFiniteNumber(nodesArray[i])) throw new Error('msh-parser: NaN or Inf detected in input file.');\n\t\t}\n\t\t/* c8 ignore next */\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$EndNodes') _MSHMesh._throwInvalidFormatError();\n\t\tthis._nodes = nodesArray;\n\n\t\t/* c8 ignore next */\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$Elements') _MSHMesh._throwInvalidFormatError();\n\n\t\t// Read the number of elements.\n\t\tconst numElements = parseInt(this._parseNextLineAsUTF8(uint8Array));\n\t\tconst elementsArray: number[][] = [];\n\t\tfor (let i = 0; i < numElements; i++) {\n\t\t\telementsArray.push([]);\n\t\t}\n\t\tthis.elements = elementsArray;\n\n\t\t// Check if all elements are tetrahedra.\n\t\tlet isTetMesh = true;\n\t\t// Loop through the elements.\n\t\tlet elementIndex = 0;\n\t\tlet tagWarning = false;\n\t\tif (isBinary) {\n\t\t\twhile (elementIndex < numElements) {\n\t\t\t\t// Parse element header.\n\t\t\t\tconst elementType = dataView.getInt32(this._offset, isLE);\n\t\t\t\tconst elementNumElements = dataView.getInt32(this._offset + 4, isLE);\n\t\t\t\tconst elementNumTags = dataView.getInt32(this._offset + 8, isLE);\n\t\t\t\t/* c8 ignore next */\n\t\t\t\tif (elementType !== 4) isTetMesh = false;\n\t\t\t\tconst numElementNodes = _MSHMesh._numNodesPerElementType(elementType);\n\t\t\t\t// Update the current file's byte offset.\n\t\t\t\tthis._offset += 12;\n\t\t\t\tfor (let i = 0; i < elementNumElements; i++) {\n\t\t\t\t\tconst index = dataView.getInt32(this._offset, isLE) - 1; // The .msh index is 1-indexed.\n\t\t\t\t\t/* c8 ignore next */\n\t\t\t\t\tif (index < 0 || index >= numElements) throw new Error(`msh-parser: Invalid element index ${index} for numElements === ${numElements}.`);\n\t\t\t\t\tthis._offset += 4;\n\t\t\t\t\t/* c8 ignore start */\n\t\t\t\t\tfor (let j = 0; j < elementNumTags; j++) {\n\t\t\t\t\t\t// const tag = dataView.getInt32(this._offset, isLE);\n\t\t\t\t\t\tif (!tagWarning) {\n\t\t\t\t\t\t\ttagWarning = true;\n\t\t\t\t\t\t\tconsole.warn('msh-parser: This library does not currently parse element tags.');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Update the current file's byte offset.\n\t\t\t\t\t\tthis._offset += 4;\n\t\t\t\t\t}\n\t\t\t\t\t/* c8 ignore stop */\n\t\t\t\t\t\n\t\t\t\t\tconst nodeIndices = elementsArray[index];\n\t\t\t\t\tfor (let j = 0; j < numElementNodes; j++) {\n\t\t\t\t\t\tconst nodeIndex = dataView.getInt32(this._offset, isLE) - 1; // The .msh index is 1-indexed.\n\t\t\t\t\t\t/* c8 ignore next */\n\t\t\t\t\t\tif (!_MSHMesh._isFiniteNumber(nodeIndex)) throw new Error('msh-parser: NaN or Inf detected in input file.');\n\t\t\t\t\t\t/* c8 ignore next */\n\t\t\t\t\t\tif (nodeIndex < 0 || nodeIndex >= numNodes) throw new Error(`msh-parser: Invalid node index ${nodeIndex} for numNodes === ${numNodes}.`);\n\t\t\t\t\t\tnodeIndices.push(nodeIndex);\n\t\t\t\t\t\t// Update the current file's byte offset.\n\t\t\t\t\t\tthis._offset += 4;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telementIndex += elementNumElements;\n\t\t\t}\n\t\t/* c8 ignore next 3 */\n\t\t} else {\n\t\t\tthrow new Error('msh-parser: This library does not currently parse non-binary .msh files.  Please submit an issue to the GitHub repo if you encounter this error and attach a sample file.');\n\t\t}\n\t\t/* c8 ignore next */\n\t\tif (this._parseNextLineAsUTF8(uint8Array) !== '$EndElements') _MSHMesh._throwInvalidFormatError();\n\n\t\tthis.isTetMesh = isTetMesh;\n\t\t// TODO: make this work for non-tet.\n\t\tif (isTetMesh) {\n\t\t\t// For tet meshes, calculate exterior faces.\n\t\t\t// First find all faces that are covered only once, these are on the boundary.\n\t\t\tconst hash: { [key: string]: number[] } = {};\n\t\t\tfor (let i = 0; i < numElements; i++) {\n\t\t\t\tconst indices = elementsArray[i];\n\t\t\t\tfor (let j = 0; j < indices.length; j++) {\n\t\t\t\t\tconst key = _MSHMesh._makeTriHash(indices[j], indices[(j + 1) % 4], indices[(j + 2) % 4]);\n\t\t\t\t\tif (hash[key]) {\n\t\t\t\t\t\thash[key].push(indices[(j + 3) % indices.length]);\n\t\t\t\t\t\t/* c8 ignore next 3 */\n\t\t\t\t\t\tif (hash[key].length > 2) {\n\t\t\t\t\t\t\tthrow new Error(`msh-parser: Hit face ${key} more than twice.`);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\thash[key] = [indices[(j + 3) % 4]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst keys = Object.keys(hash);\n\t\t\tconst exteriorFacesArray: number[][] = [];\n\t\t\tconst exteriorNodes = new Uint8Array(numNodes);\n\t\t\tfor (let i = 0, numKeys = keys.length; i < numKeys; i++) {\n\t\t\t\tconst key = keys[i];\n\t\t\t\tif (hash[key].length !== 1) continue;\n\t\t\t\tconst indices = keys[i].split(',');\n\t\t\t\tconst a = parseInt(indices[0]);\n\t\t\t\tconst b = parseInt(indices[1]);\n\t\t\t\tconst c = parseInt(indices[2]);\n\t\t\t\t// d is the internal node of this tet.\n\t\t\t\tconst d = hash[key][0];\n\t\t\t\t// Use d to calculate the winding order of the triangle.\n\t\t\t\tconst orientation = _MSHMesh._dotProduct(_MSHMesh._crossProduct(\n\t\t\t\t\t_MSHMesh._vecFromTo(a, b, nodesArray),\n\t\t\t\t\t_MSHMesh._vecFromTo(a, c, nodesArray),\n\t\t\t\t), _MSHMesh._vecFromTo(a, d, nodesArray));\n\t\t\t\texteriorFacesArray.push(orientation < 0 ? [a, b, c] : [a, c, b]);\n\t\t\t\t// Mark all nodes as exterior.\n\t\t\t\texteriorNodes[a] = 1;\n\t\t\t\texteriorNodes[b] = 1;\n\t\t\t\texteriorNodes[c] = 1;\n\t\t\t}\n\t\t\t\n\t\t\t// Also reorder the nodes so that the exterior nodes are first.\n\t\t\tlet currentIndex = 0;\n\t\t\tconst newIndices = new Int32Array(numNodes);\n\t\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\t\tif (exteriorNodes[i]) {\n\t\t\t\t\tnewIndices[i] = currentIndex;\n\t\t\t\t\tcurrentIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._numExteriorNodes = currentIndex;\n\t\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\t\tif (!exteriorNodes[i]) {\n\t\t\t\t\tnewIndices[i] = currentIndex;\n\t\t\t\t\tcurrentIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Now that we have a mapping, update nodesArrays, elementsArray, and exteriorFacesArray.\n\t\t\tconst newNodesArray = nodesArray.slice();\n\t\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\t\tfor (let j = 0; j < 3; j++) {\n\t\t\t\t\tnewNodesArray[3 * newIndices[i] + j] = nodesArray[3 * i + j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._nodes = newNodesArray;\n\t\t\tfor (let i = 0; i < numElements; i++) {\n\t\t\t\tconst indices = elementsArray[i];\n\t\t\t\tfor (let j = 0; j < indices.length; j++) {\n\t\t\t\t\tindices[j] = newIndices[indices[j]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i = 0; i < exteriorFacesArray.length; i++) {\n\t\t\t\tconst indices = exteriorFacesArray[i];\n\t\t\t\tfor (let j = 0; j < indices.length; j++) {\n\t\t\t\t\tindices[j] = newIndices[indices[j]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._exteriorFaces = exteriorFacesArray;\n\t\t}\n\t}\n\n\tget nodes() {\n\t\treturn this._nodes;\n\t}\n\n\tset nodes(nodes: Float32Array | Float64Array) {\n\t\tthrow new Error(`msh-parser: No nodes setter.`);\n\t}\n\n\tprivate _parseNextLineAsUTF8(uint8Array: Uint8Array) {\n\t\t// Find the first newline character in the uint8Array.\n\t\tconst newlineIndex = uint8Array.indexOf(10, this._offset); // 10 is the ASCII code for the newline character.\n\t\t// Decode the uint8Array as a UTF-8 encoded string up until the newline character.\n\t\tconst text = _MSHMesh.decoder.decode(uint8Array.subarray(this._offset, newlineIndex));\n\t\t// Update offset.\n\t\tthis._offset = newlineIndex + 1;\n\t\t// Return the decoded string.\n\t\treturn text;\n\t}\n\n\t/* c8 ignore next 3 */\n\tprivate static _throwInvalidFormatError() {\n\t\tthrow new Error('msh-parser: Invalid .msh file format.');\n\t}\n\n\tprivate static _isFiniteNumber(number: number) {\n\t\treturn !isNaN(number) && number !== Infinity && number !== -Infinity;\n\t}\n\n\tprivate static _numNodesPerElementType(elementType: number) {\n\t\tswitch (elementType) {\n\t\t\tcase 2:\n\t\t\t\treturn 3; // Triangle\n\t\t\tcase 3:\n\t\t\t\treturn 4; // Quad\n\t\t\tcase 4:\n\t\t\t\treturn 4; // Tetrahedron\n\t\t\tcase 5:\n\t\t\t\treturn 8; // Hexahedron\n\t\t\t/* c8 ignore next 2 */\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`msh-parser: Element type ${elementType} is not supported yet.`);\n\t\t}\n\t}\n\t\n\t// Calculates the dot product of two vectors.\n\tprivate static _dotProduct(vector1: number[], vector2: number[]) {\n\t\treturn vector1[0] * vector2[0] + vector1[1] * vector2[1] + vector1[2] * vector2[2];\n\t}\n\t\n\t// Calculates the cross product of two vectors.\n\tprivate static _crossProduct(vector1: number[], vector2: number[]) {\n\t\treturn [\n\t\t\tvector1[1] * vector2[2] - vector1[2] * vector2[1],\n\t\t\tvector1[2] * vector2[0] - vector1[0] * vector2[2],\n\t\t\tvector1[0] * vector2[1] - vector1[1] * vector2[0]\n\t\t];\n\t}\n\n\tprivate static _vecFromTo(from: number, to: number, nodesArray: Float32Array | Float64Array) {\n\t\treturn [\n\t\t\tnodesArray[3 * to] - nodesArray[3 * from],\n\t\t\tnodesArray[3 * to + 1] - nodesArray[3 * from + 1],\n\t\t\tnodesArray[3 * to + 2] - nodesArray[3 * from + 2],\n\t\t];\n\t}\n\n\tprivate static _makeTriHash(a: number, b: number, c: number) {\n\t\t// Find the minimum and maximum of the input numbers.\n\t\tconst min = Math.min(a, b, c);\n\t\tconst max = Math.max(a, b, c);\n\t  \n\t\t// Find the remaining number.\n\t\tconst remaining = a + b + c - min - max;\n\t  \n\t\t// Join the numbers in ascending order into a string with commas.\n\t\treturn`${min},${remaining},${max}`;\n\t}\n\n\tget edges() {\n\t\tif (!this._edges) {\n\t\t\tconst { elements, isTetMesh } = this;\n\t\t\t/* c8 ignore next */\n\t\t\tif (!isTetMesh) throw new Error(`msh-parser: MSHMesh.edges is not defined for non-tet meshes.`);\n\t\t\t// Calc all edges in mesh, use hash table to cover each edge only once.\n\t\t\tconst edgesHash: { [key: string]: boolean } = {};\n\t\t\tconst edges: number[] = [];\n\t\t\tfor (let i = 0, numElements = elements.length; i < numElements; i++) {\n\t\t\t\tconst elementIndices = elements[i];\n\t\t\t\t// For tetrahedra, create an edge between each pair of nodes in element.\n\t\t\t\tconst numNodes = elementIndices.length;\n\t\t\t\tfor (let j = 0; j < numNodes; j++) {\n\t\t\t\t\tfor (let k = j + 1; k < numNodes; k++) {\n\t\t\t\t\t\tconst a = elementIndices[j];\n\t\t\t\t\t\tconst b = elementIndices[k];\n\t\t\t\t\t\tconst key = `${Math.min(a, b)},${Math.max(a, b)}`;\n\t\t\t\t\t\t// Only add each edge once.\n\t\t\t\t\t\tif (edgesHash[key] === undefined) {\n\t\t\t\t\t\t\tedgesHash[key] = true;\n\t\t\t\t\t\t\tedges.push(a, b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._edges = new Uint32Array(edges);;\n\t\t}\n\t\treturn this._edges;\n\t}\n\n\tset edges(edges: Uint32Array) {\n\t\tthrow new Error(`msh-parser: No edges setter.`);\n\t}\n\n\tget exteriorEdges() {\n\t\tif (!this._exteriorEdges) {\n\t\t\tconst { isTetMesh, _exteriorFaces } = this;\n\t\t\t/* c8 ignore next */\n\t\t\tif (!isTetMesh) throw new Error(`msh-parser: MSHMesh.exteriorEdges is not defined for non-tet meshes.`);\n\t\t\tconst edges = calcEdgesFromNestedIndexedFaces({ faceIndices: _exteriorFaces! })\n\t\t\tthis._exteriorEdges = new Uint32Array(edges);\n\t\t}\n\t\treturn this._exteriorEdges;\n\t}\n\n\tset exteriorEdges(exteriorEdges: Uint32Array) {\n\t\tthrow new Error(`msh-parser: No exteriorEdges setter.`);\n\t}\n\n\tget exteriorFaces() {\n\t\t/* c8 ignore next */\n\t\tif (!this.isTetMesh || !this._exteriorFaces) throw new Error(`msh-parser: MSHMesh.exteriorFaces is not defined for non-tet meshes.`);\n\t\treturn this._exteriorFaces;\n\t}\n\n\tset exteriorFaces(exteriorFaces: number[][]) {\n\t\tthrow new Error(`msh-parser: No exteriorFaces setter.`);\n\t}\n\n\tprivate static _tetrahedronVolume(indices: number[], nodesArray: Float32Array | Float64Array) {\n\t\tconst [a, b, c, d] = indices;\n\t\t// Calculate the vectors representing the edges of the tetrahedron.\n\t\tconst v1 = _MSHMesh._vecFromTo(d, a, nodesArray);\n\t\tconst v2 = _MSHMesh._vecFromTo(d, b, nodesArray);\n\t\tconst v3 = _MSHMesh._vecFromTo(d, c, nodesArray);\n\t  \n\t\t// Calculate the volume of the tetrahedron using the formula:\"\"\n\t\t// (1/6) * |v1 . (v2 x v3)|\n\t\t// https://en.wikipedia.org/wiki/Tetrahedron#Volume\n\t\treturn Math.abs(_MSHMesh._dotProduct(v1, _MSHMesh._crossProduct(v2, v3))) / 6;\n\t}\n\n\tget elementVolumes() {\n\t\tif (!this._elementVolumes) {\n\t\t\tconst { elements, nodes, isTetMesh } = this;\n\t\t\t/* c8 ignore next */\n\t\t\tif (!isTetMesh) throw new Error(`msh-parser: MSHMesh.elementVolumes is not defined for non-tet meshes.`);\n\t\t\tconst numElements = elements.length;\n\t\t\tconst volumes = new Float32Array(numElements);\n\t\t\tfor (let i = 0; i < numElements; i++) {\n\t\t\t\tvolumes[i] = _MSHMesh._tetrahedronVolume(elements[i], nodes);\n\t\t\t}\n\t\t\tthis._elementVolumes = volumes;\n\t\t}\n\t\treturn this._elementVolumes;\n\t}\n\n\tset elementVolumes(elementVolumes: Float32Array) {\n\t\tthrow new Error(`msh-parser: No elementVolumes setter.`);\n\t}\n\n\tget nodalVolumes() {\n\t\tif (!this._nodalVolumes) {\n\t\t\tconst { elements, nodes, isTetMesh } = this;\n\t\t\t/* c8 ignore next */\n\t\t\tif (!isTetMesh) throw new Error(`msh-parser: MSHMesh.nodalVolumes is not defined for non-tet meshes.`);\n\t\t\tconst { elementVolumes } = this;\n\t\t\tconst nodalVolumes = new Float32Array(nodes.length / 3);\n\t\t\tfor (let i = 0, numElements = elements.length; i < numElements; i++) {\n\t\t\t\tconst nodeIndices = elements[i];\n\t\t\t\tconst numNodeIndices = nodeIndices.length;\n\t\t\t\tfor (let j = 0; j < numNodeIndices; j++) {\n\t\t\t\t\tconst nodeIndex = nodeIndices[j];\n\t\t\t\t\t// Split element volume evenly across adjacent nodes.\n\t\t\t\t\tnodalVolumes[nodeIndex] += elementVolumes[i] / numNodeIndices;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._nodalVolumes = nodalVolumes;\n\t\t}\n\t\treturn this._nodalVolumes;\n\t}\n\n\tset nodalVolumes(nodalVolumes: Float32Array) {\n\t\tthrow new Error(`msh-parser: No nodalVolumes setter.`);\n\t}\n\n\tget numExteriorNodes() {\n\t\t/* c8 ignore next */\n\t\tif (!this.isTetMesh || !this._numExteriorNodes) throw new Error(`msh-parser: MSHMesh.numExteriorNodes is not defined for non-tet meshes.`);\n\t\treturn this._numExteriorNodes;\n\t}\n\n\tset numExteriorNodes(numExteriorNodes: number) {\n\t\tthrow new Error(`msh-parser: No numExteriorNodes setter.`);\n\t}\n\n\tget boundingBox() {\n\t\tif (!this._boundingBox) {\n\t\t\tthis._boundingBox = calcBoundingBox({\n\t\t\t\tvertices: this.nodes,\n\t\t\t});\n\t\t}\n\t\treturn this._boundingBox;\n\t}\n\n\tset boundingBox(boundingBox: { min: [number, number, number], max: [number, number, number] }) {\n\t\tthrow new Error(`msh-parser: No boundingBox setter.`);\n\t}\n\n\t/**\n\t * Scales nodes to unit bounding box and centers around origin.\n\t */\n\tscaleNodesToUnitBoundingBox() {\n\t\tscaleVerticesToUnitBoundingBox({\n\t\t\tvertices: this.nodes,\n\t\t\tboundingBox: this.boundingBox,\n\t\t});\n\t\tdelete this._boundingBox;\n\t\tdelete this._nodalVolumes;\n\t\tdelete this._elementVolumes;\n\t\treturn this;\n\t}\n}\n","/**\n * Returns the bounding box of the mesh.\n */\nexport function calcBoundingBox(mesh) {\n    const { vertices } = mesh;\n    const numVertices = vertices.length / 3;\n    const min = [Infinity, Infinity, Infinity];\n    const max = [-Infinity, -Infinity, -Infinity];\n    for (let i = 0; i < numVertices; i++) {\n        min[0] = Math.min(min[0], vertices[3 * i]);\n        min[1] = Math.min(min[1], vertices[3 * i + 1]);\n        min[2] = Math.min(min[2], vertices[3 * i + 2]);\n        max[0] = Math.max(max[0], vertices[3 * i]);\n        max[1] = Math.max(max[1], vertices[3 * i + 1]);\n        max[2] = Math.max(max[2], vertices[3 * i + 2]);\n    }\n    return { min, max };\n}\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh contains indexed faces.\n * Vertices are grouped into faces of any size: [[f01, f0b, f0c], [f1a, f1b, f1c, f1d], ...]\n */\nexport function calcEdgesFromNestedIndexedFaces(mesh) {\n    const { faceIndices } = mesh;\n    // Handle edges on indexed faces.\n    const numFaces = faceIndices.length;\n    // Use hash to calc edges.\n    const edgesHash = {};\n    const edges = [];\n    for (let i = 0; i < numFaces; i++) {\n        const face = faceIndices[i];\n        const numVertices = face.length;\n        for (let j = 0; j < numVertices; j++) {\n            const index1 = face[j];\n            const index2 = face[(j + 1) % numVertices];\n            const key = `${Math.min(index1, index2)},${Math.max(index1, index2)}`;\n            // Only add each edge once.\n            if (edgesHash[key] === undefined) {\n                edgesHash[key] = true;\n                edges.push(index1, index2);\n            }\n        }\n    }\n    return edges;\n}\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh contains indexed faces.\n * Assumes flat list of triangle faces: [f0a, f0b, f0c, f1a, f1b, f1c, ...]\n */\nexport function calcEdgesFromIndexedFaces(mesh) {\n    const { faceIndices } = mesh;\n    // Handle edges on indexed faces.\n    const numFaces = faceIndices.length / 3;\n    // Use hash to calc edges.\n    const edgesHash = {};\n    const edges = [];\n    for (let i = 0; i < numFaces; i++) {\n        for (let j = 0; j < 3; j++) {\n            const index1 = faceIndices[3 * i + j];\n            const index2 = faceIndices[3 * i + (j + 1) % 3];\n            const key = `${Math.min(index1, index2)},${Math.max(index1, index2)}`;\n            // Only add each edge once.\n            if (edgesHash[key] === undefined) {\n                edgesHash[key] = true;\n                edges.push(index1, index2);\n            }\n        }\n    }\n    return edges;\n}\n/**\n * Returns the edges in the mesh data (without duplicates).\n * Assumes mesh vertices are groups in sets of three to a face (triangle mesh).\n */\nexport function calcEdgesFromNonIndexedFaces(mesh) {\n    const { vertices } = mesh;\n    const numVertices = vertices.length / 3;\n    // Vertices are grouped in sets of three to a face.\n    const numFaces = numVertices / 3;\n    const edges = new Uint32Array(6 * numFaces);\n    for (let i = 0; i < numFaces; i++) {\n        const index = 3 * i;\n        for (let j = 0; j < 3; j++) {\n            const edgeIndex = 6 * i + 2 * j;\n            edges[edgeIndex] = index + j;\n            edges[edgeIndex + 1] = index + (j + 1) % 3;\n        }\n    }\n    return edges;\n}\n/**\n * Scales vertex positions (in place, unless target provided) to unit bounding box and centers around origin.\n * Assumes all vertex positions are used in mesh.\n */\nexport function scaleVerticesToUnitBoundingBox(mesh, target = mesh.vertices) {\n    const { vertices, boundingBox } = mesh;\n    const { min, max } = boundingBox;\n    const diff = [max[0] - min[0], max[1] - min[1], max[2] - min[2]];\n    const center = [(max[0] + min[0]) / 2, (max[1] + min[1]) / 2, (max[2] + min[2]) / 2];\n    const scale = Math.max(diff[0], diff[1], diff[2]);\n    const numNodes = vertices.length / 3;\n    for (let i = 0; i < numNodes; i++) {\n        for (let j = 0; j < 3; j++) {\n            // Uniform scale.\n            target[3 * i + j] = (vertices[3 * i + j] - center[j]) / scale;\n        }\n    }\n}\n/**\n * Merge coincident vertices and index faces.\n */\nexport function mergeVertices(mesh) {\n    const { vertices } = mesh;\n    const numFaces = vertices.length / 9;\n    const verticesMerged = [];\n    const facesIndexed = new Uint32Array(numFaces * 3);\n    // Use hash to merge vertices.\n    const vertexHash = {};\n    for (let i = 0; i < numFaces; i++) {\n        for (let j = 0; j < 3; j++) {\n            const vertexIndex = 9 * i + 3 * j;\n            const faceIndex = 3 * i;\n            const positionX = vertices[vertexIndex];\n            const positionY = vertices[vertexIndex + 1];\n            const positionZ = vertices[vertexIndex + 2];\n            const key = `${positionX},${positionY},${positionZ}`;\n            let mergedVertexIndex = vertexHash[key];\n            if (mergedVertexIndex !== undefined) {\n                facesIndexed[faceIndex + j] = mergedVertexIndex;\n            }\n            else {\n                // Add new vertex.\n                mergedVertexIndex = verticesMerged.length / 3;\n                facesIndexed[faceIndex + j] = mergedVertexIndex;\n                vertexHash[key] = mergedVertexIndex;\n                verticesMerged.push(positionX, positionY, positionZ);\n            }\n        }\n    }\n    return {\n        verticesMerged,\n        facesIndexed,\n    };\n}\n//# sourceMappingURL=3d-mesh-utils.js.map"],"names":["parseMsh","data","_MSHMesh","loadMsh","urlOrFile","callback","window","request","XMLHttpRequest","open","responseType","onload","mesh","response","send","import","then","fs","buffer","readFileSync","reader","FileReader","result","readAsArrayBuffer","constructor","this","_offset","arrayBuffer","Uint8Array","dataView","DataView","uint8Array","_parseNextLineAsUTF8","_throwInvalidFormatError","version","type","dataSize","split","map","el","parseFloat","isNaN","Error","doublePrecision","isBinary","isLE","getInt32","numNodes","parseInt","nodesArray","Float64Array","Float32Array","i","index","getFloat64","getFloat32","length","_isFiniteNumber","_nodes","numElements","elementsArray","push","elements","isTetMesh","elementIndex","tagWarning","elementType","elementNumElements","elementNumTags","numElementNodes","_numNodesPerElementType","j","console","warn","nodeIndices","nodeIndex","hash","indices","key","_makeTriHash","keys","Object","exteriorFacesArray","exteriorNodes","numKeys","a","b","c","d","orientation","_dotProduct","_crossProduct","_vecFromTo","currentIndex","newIndices","Int32Array","_numExteriorNodes","newNodesArray","slice","_exteriorFaces","nodes","newlineIndex","indexOf","text","decoder","decode","subarray","static","number","Infinity","vector1","vector2","from","to","min","Math","max","edges","_edges","edgesHash","elementIndices","k","undefined","Uint32Array","exteriorEdges","_exteriorEdges","faceIndices","numFaces","face","numVertices","index1","index2","calcEdgesFromNestedIndexedFaces","exteriorFaces","v1","v2","v3","abs","elementVolumes","_elementVolumes","volumes","_tetrahedronVolume","nodalVolumes","_nodalVolumes","numNodeIndices","numExteriorNodes","boundingBox","_boundingBox","vertices","calcBoundingBox","scaleNodesToUnitBoundingBox","target","diff","center","scale","scaleVerticesToUnitBoundingBox","TextDecoder","Promise","resolve"],"mappings":"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"}